<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    id(&quot;org.jetbrains.kotlin.kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.attendance_tracker&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.lol&quot;&#10;        minSdk = 33&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.room.runtime)&#10;    implementation(libs.room.ktx)&#10;    implementation(&quot;androidx.navigation:navigation-compose:2.7.7&quot;)&#10;    implementation(&quot;androidx.compose.material:material-icons-extended&quot;)&#10;    implementation(&quot;io.github.vanpra.compose-material-dialogs:datetime:0.9.0&quot;)&#10;    implementation(&quot;io.github.vanpra.compose-material-dialogs:core:0.9.0&quot;)&#10;    kapt(libs.room.compiler)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    id(&quot;org.jetbrains.kotlin.kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.attendance_tracker&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.lol&quot;&#10;        minSdk = 33&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.room.runtime)&#10;    implementation(libs.room.ktx)&#10;    implementation(&quot;androidx.navigation:navigation-compose:2.7.7&quot;)&#10;    implementation(&quot;androidx.compose.material:material-icons-extended&quot;)&#10;    implementation(&quot;io.github.vanpra.compose-material-dialogs:datetime:0.9.0&quot;)&#10;    implementation(&quot;io.github.vanpra.compose-material-dialogs:core:0.9.0&quot;)&#10;    implementation(&quot;org.apache.poi:poi-ooxml:5.2.3&quot;)&#10;    kapt(libs.room.compiler)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/MainActivity.kt" />
              <option name="originalContent" value="package com.example.attendance_tracker&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.ui.Modifier&#10;import com.example.attendance_tracker.ui.navigation.AppNavHost&#10;import com.example.attendance_tracker.ui.navigation.BottomNavItem&#10;import com.example.attendance_tracker.ui.theme.LOLTheme&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.room.Room&#10;import com.example.attendance_tracker.data.AppDatabase&#10;import com.example.attendance_tracker.data.SubjectRepository&#10;import com.example.attendance_tracker.repository.TimetableRepository&#10;import com.example.attendance_tracker.viewmodel.TimetableViewModel&#10;import com.example.attendance_tracker.viewmodel.TimetableViewModelFactory&#10;import androidx.compose.runtime.remember&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            LOLTheme {&#10;                val navController = rememberNavController()&#10;                val context = this&#10;                val db = remember {&#10;                    Room.databaseBuilder(&#10;                        context.applicationContext,&#10;                        AppDatabase::class.java,&#10;                        &quot;attendance_db&quot;&#10;                    )&#10;                    .fallbackToDestructiveMigration()&#10;                    .build()&#10;                }&#10;                val repository = remember { SubjectRepository(db.subjectDao()) }&#10;                val timetableRepository = remember { TimetableRepository(db.timetableDao()) }&#10;                val timetableViewModel: TimetableViewModel = androidx.lifecycle.viewmodel.compose.viewModel(&#10;                    factory = TimetableViewModelFactory(timetableRepository)&#10;                )&#10;                val items = listOf(&#10;                    BottomNavItem.Home,&#10;                    BottomNavItem.Subjects,&#10;                    BottomNavItem.Timetable,&#10;                    BottomNavItem.CommonSlots&#10;                )&#10;                val commonSlotViewModel: com.example.attendance_tracker.viewmodel.CommonSlotViewModel = androidx.lifecycle.viewmodel.compose.viewModel()&#10;                // Always call insertDefaultSlotsIfEmpty; it only inserts if table is empty&#10;                commonSlotViewModel.insertDefaultSlotsIfEmpty()&#10;                val attendanceRepository = remember { com.example.attendance_tracker.repository.AttendanceRepository(db.attendanceDao(), db.subjectDao(), repository) }&#10;                val attendanceViewModel = remember { com.example.attendance_tracker.viewmodel.AttendanceViewModel(attendanceRepository) }&#10;                Scaffold(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    bottomBar = {&#10;                        NavigationBar {&#10;                            val currentRoute = navController.currentBackStackEntry?.destination?.route&#10;                            items.forEach { item -&gt;&#10;                                NavigationBarItem(&#10;                                    icon = { Icon(item.icon, contentDescription = item.label) },&#10;                                    label = { Text(item.label) },&#10;                                    selected = currentRoute == item.route,&#10;                                    onClick = {&#10;                                        if (currentRoute != item.route) {&#10;                                            navController.navigate(item.route) {&#10;                                                popUpTo(navController.graph.startDestinationId) { saveState = true }&#10;                                                launchSingleTop = true&#10;                                                restoreState = true&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                ) { innerPadding -&gt;&#10;                    AppNavHost(&#10;                        navController = navController,&#10;                        repository = repository,&#10;                        timetableViewModel = timetableViewModel,&#10;                        commonSlotViewModel = commonSlotViewModel,&#10;                        attendanceViewModel = attendanceViewModel,&#10;                        modifier = Modifier.padding(innerPadding)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.attendance_tracker&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.ui.Modifier&#10;import com.example.attendance_tracker.ui.navigation.AppNavHost&#10;import com.example.attendance_tracker.ui.navigation.BottomNavItem&#10;import com.example.attendance_tracker.ui.theme.LOLTheme&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.room.Room&#10;import com.example.attendance_tracker.data.AppDatabase&#10;import com.example.attendance_tracker.data.SubjectRepository&#10;import com.example.attendance_tracker.repository.TimetableRepository&#10;import com.example.attendance_tracker.viewmodel.TimetableViewModel&#10;import com.example.attendance_tracker.viewmodel.TimetableViewModelFactory&#10;import androidx.compose.runtime.remember&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            LOLTheme {&#10;                val navController = rememberNavController()&#10;                val context = this&#10;                val db = remember {&#10;                    Room.databaseBuilder(&#10;                        context.applicationContext,&#10;                        AppDatabase::class.java,&#10;                        &quot;attendance_db&quot;&#10;                    )&#10;                    .fallbackToDestructiveMigration()&#10;                    .build()&#10;                }&#10;                val repository = remember { SubjectRepository(db.subjectDao()) }&#10;                val timetableRepository = remember { TimetableRepository(db.timetableDao()) }&#10;                val timetableViewModel: TimetableViewModel = androidx.lifecycle.viewmodel.compose.viewModel(&#10;                    factory = TimetableViewModelFactory(timetableRepository)&#10;                )&#10;                val items = listOf(&#10;                    BottomNavItem.Home,&#10;                    BottomNavItem.Subjects,&#10;                    BottomNavItem.Timetable,&#10;                    BottomNavItem.CommonSlots&#10;                )&#10;                val commonSlotViewModel: com.example.attendance_tracker.viewmodel.CommonSlotViewModel = androidx.lifecycle.viewmodel.compose.viewModel()&#10;                // Always call insertDefaultSlotsIfEmpty; it only inserts if table is empty&#10;                commonSlotViewModel.insertDefaultSlotsIfEmpty()&#10;                val attendanceRepository = remember { com.example.attendance_tracker.repository.AttendanceRepository(db.attendanceDao(), db.subjectDao(), repository, timetableRepository) }&#10;                val attendanceViewModel = remember { com.example.attendance_tracker.viewmodel.AttendanceViewModel(attendanceRepository) }&#10;                Scaffold(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    bottomBar = {&#10;                        NavigationBar {&#10;                            val currentRoute = navController.currentBackStackEntry?.destination?.route&#10;                            items.forEach { item -&gt;&#10;                                NavigationBarItem(&#10;                                    icon = { Icon(item.icon, contentDescription = item.label) },&#10;                                    label = { Text(item.label) },&#10;                                    selected = currentRoute == item.route,&#10;                                    onClick = {&#10;                                        if (currentRoute != item.route) {&#10;                                            navController.navigate(item.route) {&#10;                                                popUpTo(navController.graph.startDestinationId) { saveState = true }&#10;                                                launchSingleTop = true&#10;                                                restoreState = true&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                ) { innerPadding -&gt;&#10;                    AppNavHost(&#10;                        navController = navController,&#10;                        repository = repository,&#10;                        timetableViewModel = timetableViewModel,&#10;                        commonSlotViewModel = commonSlotViewModel,&#10;                        attendanceViewModel = attendanceViewModel,&#10;                        modifier = Modifier.padding(innerPadding)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/data/AttendanceDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/data/AttendanceDao.kt" />
              <option name="originalContent" value="package com.example.attendance_tracker.data&#10;&#10;import androidx.room.*&#10;&#10;@Dao&#10;interface AttendanceDao {&#10;    @Query(&quot;DELETE FROM attendance WHERE subjectId = :subjectId&quot;)&#10;    suspend fun deleteAllForSubject(subjectId: Int)&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAttendance(attendance: Attendance)&#10;&#10;    @Query(&quot;SELECT * FROM attendance WHERE subjectId = :subjectId AND slotId = :slotId ORDER BY date DESC&quot;)&#10;    suspend fun getAttendanceForSlot(subjectId: Int, slotId: Int): List&lt;Attendance&gt;&#10;&#10;    // Insert manual update history&#10;    @Insert&#10;    suspend fun insertManualHistory(attendance: Attendance)&#10;&#10;    @Query(&quot;SELECT * FROM attendance WHERE subjectId = :subjectId ORDER BY date DESC&quot;)&#10;    suspend fun getAttendanceForSubject(subjectId: Int): List&lt;Attendance&gt;&#10;&#10;    @Query(&quot;SELECT * FROM attendance WHERE subjectId = :subjectId AND date = :date LIMIT 1&quot;)&#10;    suspend fun getAttendanceForSubjectOnDate(subjectId: Int, date: String): Attendance?&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM attendance WHERE subjectId = :subjectId AND status = :status&quot;)&#10;    suspend fun getCountByStatus(subjectId: Int, status: AttendanceStatus): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM attendance WHERE subjectId = :subjectId&quot;)&#10;    suspend fun getTotalMarked(subjectId: Int): Int&#10;" />
              <option name="updatedContent" value="package com.example.attendance_tracker.data&#13;&#10;&#13;&#10;import androidx.room.*&#13;&#10;&#13;&#10;@Dao&#13;&#10;interface AttendanceDao {&#13;&#10;    @Query(&quot;DELETE FROM attendance WHERE subjectId = :subjectId&quot;)&#13;&#10;    suspend fun deleteAllForSubject(subjectId: Int)&#13;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#13;&#10;    suspend fun insertAttendance(attendance: Attendance)&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM attendance WHERE subjectId = :subjectId AND slotId = :slotId ORDER BY date DESC&quot;)&#13;&#10;    suspend fun getAttendanceForSlot(subjectId: Int, slotId: Int): List&lt;Attendance&gt;&#13;&#10;&#13;&#10;    // Insert manual update history&#13;&#10;    @Insert&#13;&#10;    suspend fun insertManualHistory(attendance: Attendance)&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM attendance WHERE subjectId = :subjectId ORDER BY date DESC&quot;)&#13;&#10;    suspend fun getAttendanceForSubject(subjectId: Int): List&lt;Attendance&gt;&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM attendance WHERE subjectId = :subjectId AND date = :date LIMIT 1&quot;)&#13;&#10;    suspend fun getAttendanceForSubjectOnDate(subjectId: Int, date: String): Attendance?&#13;&#10;&#13;&#10;    @Query(&quot;SELECT COUNT(*) FROM attendance WHERE subjectId = :subjectId AND status = :status&quot;)&#13;&#10;    suspend fun getCountByStatus(subjectId: Int, status: AttendanceStatus): Int&#13;&#10;&#13;&#10;    @Query(&quot;SELECT COUNT(*) FROM attendance WHERE subjectId = :subjectId&quot;)&#13;&#10;    suspend fun getTotalMarked(subjectId: Int): Int&#13;&#10;&#13;&#10;    @Query(&quot;DELETE FROM attendance WHERE subjectId = :subjectId AND date = :date&quot;)&#13;&#10;    suspend fun deleteAttendanceForSubjectOnDate(subjectId: Int, date: String)&#13;&#10;&#13;&#10;    @Query(&quot;UPDATE attendance SET status = :status WHERE subjectId = :subjectId AND date = :date&quot;)&#13;&#10;    suspend fun updateAttendanceStatusForSubjectOnDate(subjectId: Int, date: String, status: AttendanceStatus)&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/ui/components/TimetableEntryCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/ui/components/TimetableEntryCard.kt" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/ui/screens/HomeScreen.kt" />
              <option name="originalContent" value="package com.example.attendance_tracker.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.foundation.background&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.Error&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.unit.dp&#10;import com.example.attendance_tracker.ui.components.CustomDismissValue&#10;import java.time.format.DateTimeParseException&#10;import kotlinx.coroutines.launch&#10;import com.example.attendance_tracker.viewmodel.TimetableViewModel&#10;import com.example.attendance_tracker.data.TimetableEntry&#10;import com.example.attendance_tracker.data.SubjectRepository&#10;import com.example.attendance_tracker.viewmodel.CommonSlotViewModel&#10;import com.example.attendance_tracker.viewmodel.AttendanceViewModel&#10;import com.example.attendance_tracker.data.AttendanceStatus&#10;import java.time.LocalDate&#10;import java.time.format.TextStyle&#10;import java.util.Locale&#10;import java.time.LocalTime&#10;import java.time.format.DateTimeFormatter&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import com.example.attendance_tracker.ui.components.*&#10;&#10;// Define a single DateTimeFormatter instance for reuse&#10;val timeFormatter = DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US)&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun HomeScreen(&#10;    timetableViewModel: TimetableViewModel,&#10;    subjectRepository: SubjectRepository,&#10;    commonSlotViewModel: CommonSlotViewModel = androidx.lifecycle.viewmodel.compose.viewModel(),&#10;    attendanceViewModel: AttendanceViewModel&#10;) {&#10;    val today = LocalDate.now().dayOfWeek.getDisplayName(TextStyle.FULL, Locale.US)&#10;    val timetableEntries by timetableViewModel.getEntriesForDay(today).collectAsState()&#10;    var showDialog by remember { mutableStateOf(false) }&#10;    var editingEntry by remember { mutableStateOf&lt;TimetableEntry?&gt;(null) }&#10;    var subject by remember { mutableStateOf(&quot;&quot;) }&#10;    val subjects by subjectRepository.allSubjects.collectAsState(initial = emptyList())&#10;    val slotEntities by commonSlotViewModel.slots.collectAsState()&#10;    var selectedSlotLabel by remember { mutableStateOf(&quot;&quot;) }&#10;    var startTime by remember { mutableStateOf(&quot;&quot;) }&#10;    var endTime by remember { mutableStateOf(&quot;&quot;) }&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val todayDate = LocalDate.now()&#10;    val dayOfWeek = todayDate.dayOfWeek.getDisplayName(TextStyle.FULL, Locale.US)&#10;    val dateStr = todayDate.format(java.time.format.DateTimeFormatter.ofPattern(&quot;dd MMMM yyyy&quot;))&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Today - $dayOfWeek's Timetable&quot;) },&#10;                actions = {&#10;                    IconButton(onClick = {&#10;                        editingEntry = null&#10;                        subject = &quot;&quot;&#10;                        startTime = &quot;&quot;&#10;                        endTime = &quot;&quot;&#10;                        selectedSlotLabel = &quot;&quot;&#10;                        showDialog = true&#10;                    }) {&#10;                        Icon(Icons.Filled.Add, contentDescription = &quot;Add Timetable Entry&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Box(modifier = Modifier.fillMaxSize().padding(innerPadding)) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(text = dateStr, style = MaterialTheme.typography.titleMedium)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;            }&#10;            if (timetableEntries.isEmpty()) {&#10;                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;                    Text(&quot;No timetable entries for today.&quot;)&#10;                }&#10;            } else {&#10;                LazyColumn(modifier = Modifier.fillMaxSize()) {&#10;                    items(timetableEntries) { entry -&gt;&#10;                        // Find the slot(s) for this entry&#10;                        val entrySlots = slotEntities.filter {&#10;                            (safeParseTime(it.startTime) ?: LocalTime.MIN) &gt;= (safeParseTime(entry.startTime) ?: LocalTime.MIN) &amp;&amp;&#10;                                    (safeParseTime(it.endTime) ?: LocalTime.MAX) &lt;= (safeParseTime(entry.endTime) ?: LocalTime.MAX)&#10;                        }&#10;                        val selectedSlots: List&lt;Int&gt; = entrySlots.map { it.id }&#10;                        val dismissState = rememberCustomDismissState()&#10;                        // Overlap prevention logic&#10;                        val isOverlapping = slotEntities.any { slot -&gt;&#10;                            slot.id != entry.id &amp;&amp;&#10;                            (safeParseTime(slot.startTime)?.isBefore(safeParseTime(entry.endTime)) == true &amp;&amp;&#10;                             safeParseTime(slot.endTime)?.isAfter(safeParseTime(entry.startTime)) == true)&#10;                        }&#10;                        if (isOverlapping) {&#10;                            errorMessage = &quot;Time slot overlaps with another entry!&quot;&#10;                        } else {&#10;                            errorMessage = null&#10;                        }&#10;                        if (dismissState.value == CustomDismissValue.DismissedToEnd || dismissState.value == CustomDismissValue.DismissedToStart) {&#10;                            val subjectId = subjects.find { it.name == entry.subject }?.id ?: 0&#10;                            LaunchedEffect(dismissState.value) {&#10;                                val attendance = attendanceViewModel.getAttendanceStatusForSubjectOnDate(subjectId, todayDate.toString())&#10;                                if (attendance == null) {&#10;                                    // No record yet, insert new&#10;                                    attendanceViewModel.markAttendance(&#10;                                        subjectId = subjectId,&#10;                                        selectedSlots = selectedSlots,&#10;                                        date = todayDate.toString(),&#10;                                        status = if (dismissState.value == CustomDismissValue.DismissedToEnd) AttendanceStatus.PRESENT else AttendanceStatus.ABSENT&#10;                                    )&#10;                                } else {&#10;                                    // Record exists, update status&#10;                                    attendanceViewModel.updateAttendanceStatusForSubjectOnDate(&#10;                                        subjectId,&#10;                                        todayDate.toString(),&#10;                                        if (dismissState.value == CustomDismissValue.DismissedToEnd) AttendanceStatus.PRESENT else AttendanceStatus.ABSENT&#10;                                    )&#10;                                }&#10;                                errorMessage = if (dismissState.value == CustomDismissValue.DismissedToEnd) {&#10;                                    &quot;Marked Present for ${entry.subject}&quot;&#10;                                } else {&#10;                                    &quot;Marked Absent for ${entry.subject}&quot;&#10;                                }&#10;                                dismissState.value = CustomDismissValue.Default&#10;                            }&#10;                        }&#10;                        CustomSwipeToDismiss(&#10;                            state = dismissState,&#10;                            background = { direction -&gt;&#10;                                val color = when (direction) {&#10;                                    CustomDismissDirection.StartToEnd -&gt; MaterialTheme.colorScheme.primary&#10;                                    CustomDismissDirection.EndToStart -&gt; MaterialTheme.colorScheme.error&#10;                                }&#10;                                Box(&#10;                                    Modifier&#10;                                        .fillMaxSize()&#10;                                        .background(color)&#10;                                )&#10;                            },&#10;                            content = {&#10;                                val subjectId = subjects.find { it.name == entry.subject }?.id&#10;                                val attendanceStatus by produceState&lt;AttendanceStatus?&gt;(null, subjectId, todayDate) {&#10;                                    value = if (subjectId != null) {&#10;                                        attendanceViewModel.getAttendanceStatusForSubjectOnDate(subjectId, todayDate.toString())&#10;                                    } else null&#10;                                }&#10;                                Card(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(8.dp),&#10;                                    elevation = CardDefaults.cardElevation(2.dp),&#10;                                    colors = CardDefaults.cardColors(&#10;                                        containerColor = when (attendanceStatus) {&#10;                                            AttendanceStatus.PRESENT -&gt; Color(0xFFA5D6A7)&#10;                                            AttendanceStatus.ABSENT -&gt; Color(0xFFEF9A9A)&#10;                                            null -&gt; MaterialTheme.colorScheme.surface&#10;                                            else -&gt; MaterialTheme.colorScheme.surface&#10;                                        }&#10;                                    )&#10;                                ) {&#10;                                    Column(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .padding(16.dp)&#10;                                    ) {&#10;                                        Text(entry.subject, style = MaterialTheme.typography.titleMedium)&#10;                                        Text(&quot;${entry.startTime} - ${entry.endTime}&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                        // --- Attendance Progress Bar ---&#10;                                        val subjectObj = subjects.find { it.name == entry.subject }&#10;                                        val attended = subjectObj?.attendedClasses ?: 0&#10;                                        val total = subjectObj?.totalClasses ?: 0&#10;                                        val threshold = subjectObj?.threshold ?: 75&#10;                                        val attendancePercent = if (total &gt; 0) attended * 100 / total else 0&#10;                                        val thresholdPercent = threshold&#10;                                        Spacer(modifier = Modifier.height(8.dp))&#10;                                        Box(modifier = Modifier.fillMaxWidth().height(20.dp)) {&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxSize()&#10;                                                    .background(MaterialTheme.colorScheme.secondary.copy(alpha = 0.5f))&#10;                                            )&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxHeight()&#10;                                                    .fillMaxWidth(fraction = thresholdPercent / 100f)&#10;                                                    .background(MaterialTheme.colorScheme.error.copy(alpha = 0.75f))&#10;                                            )&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxHeight()&#10;                                                    .fillMaxWidth(fraction = attendancePercent / 100f)&#10;                                                    .background(MaterialTheme.colorScheme.primary)&#10;                                            )&#10;                                        }&#10;                                        Spacer(modifier = Modifier.height(2.dp))&#10;                                        Row(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.SpaceBetween&#10;                                        ) {&#10;                                            Text(&quot;Attendance: $attendancePercent%&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                            Text(&quot;Threshold: $thresholdPercent%&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                        }&#10;                                        // --- Edit/Delete Controls ---&#10;                                        Row(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.End&#10;                                        ) {&#10;                                            IconButton(onClick = {&#10;                                                editingEntry = entry&#10;                                                subject = entry.subject&#10;                                                startTime = entry.startTime&#10;                                                endTime = entry.endTime&#10;                                                showDialog = true&#10;                                            }) {&#10;                                                Icon(Icons.Filled.Edit, contentDescription = &quot;Edit&quot;)&#10;                                            }&#10;                                            IconButton(onClick = {&#10;                                                coroutineScope.launch {&#10;                                                    timetableViewModel.deleteEntry(entry)&#10;                                                    errorMessage = &quot;Entry deleted&quot;&#10;                                                }&#10;                                            }) {&#10;                                                Icon(Icons.Filled.Delete, contentDescription = &quot;Delete&quot;)&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (showDialog) {&#10;                var subjectDropdownExpanded by remember { mutableStateOf(false) }&#10;                val subjectOptions = subjects.map { it.name }&#10;                var selectedSubject by remember { mutableStateOf(subjectOptions.firstOrNull() ?: &quot;&quot;) }&#10;                val selectedSlotIds = remember { mutableStateListOf&lt;Int&gt;() }&#10;                var slotSelectionError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;                // Reset errorMessage when subject or slot selection changes&#10;                LaunchedEffect(selectedSubject, selectedSlotIds) {&#10;                    errorMessage = null&#10;                }&#10;&#10;                AlertDialog(&#10;                    onDismissRequest = { showDialog = false },&#10;                    confirmButton = {&#10;                        Button(onClick = {&#10;                            if (selectedSubject.isBlank() || selectedSlotIds.isEmpty() || slotSelectionError != null) {&#10;                                errorMessage = slotSelectionError ?: &quot;Please select subject and valid slots.&quot;&#10;                                return@Button&#10;                            }&#10;                            val selectedSlots = slotEntities.filter { selectedSlotIds.contains(it.id) }&#10;                                .sortedBy { LocalTime.parse(it.startTime, timeFormatter) }&#10;                            val newStart = LocalTime.parse(selectedSlots.first().startTime, timeFormatter)&#10;                            val newEnd = LocalTime.parse(selectedSlots.last().endTime, timeFormatter)&#10;                            val conflict = timetableEntries.any { entry -&gt;&#10;                                if (editingEntry != null &amp;&amp; entry.id == editingEntry!!.id) return@any false // skip self when editing&#10;                                val entryStart = LocalTime.parse(entry.startTime, timeFormatter)&#10;                                val entryEnd = LocalTime.parse(entry.endTime, timeFormatter)&#10;                                val timeOverlap = newStart &lt; entryEnd &amp;&amp; newEnd &gt; entryStart&#10;                                val slotOverlap = entry.slotIds.any { selectedSlotIds.contains(it) }&#10;                                timeOverlap || slotOverlap&#10;                            }&#10;                            if (conflict) {&#10;                                errorMessage = &quot;Conflict: Overlapping time or duplicate slot with another entry.&quot;&#10;                                return@Button&#10;                            }&#10;                            coroutineScope.launch {&#10;                                val startStr = selectedSlots.first().startTime&#10;                                val endStr = selectedSlots.last().endTime&#10;                                if (editingEntry == null) {&#10;                                    timetableViewModel.addEntry(&#10;                                        TimetableEntry(&#10;                                            dayOfWeek = today ,&#10;                                            subject = selectedSubject,&#10;                                            startTime = startStr,&#10;                                            endTime = endStr,&#10;                                            slotIds = selectedSlotIds.toList()&#10;                                        )&#10;                                    )&#10;                                    errorMessage = &quot;Entry added&quot;&#10;                                } else {&#10;                                    timetableViewModel.deleteEntry(editingEntry!!)&#10;                                    timetableViewModel.addEntry(&#10;                                        TimetableEntry(&#10;                                            id = editingEntry!!.id,&#10;                                            dayOfWeek = today ,&#10;                                            subject = selectedSubject,&#10;                                            startTime = startStr,&#10;                                            endTime = endStr,&#10;                                            slotIds = selectedSlotIds.toList()&#10;                                        )&#10;                                    )&#10;                                    errorMessage = &quot;Entry updated&quot;&#10;                                }&#10;                                showDialog = false&#10;                            }&#10;                        }) {&#10;                            Text(&quot;Save&quot;)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        OutlinedButton(onClick = { showDialog = false }) {&#10;                            Text(&quot;Cancel&quot;)&#10;                        }&#10;                    },&#10;                    title = { Text(if (editingEntry == null) &quot;Add Timetable Entry&quot; else &quot;Edit Timetable Entry&quot;) },&#10;                    text = {&#10;                        Column {&#10;                            Text(&quot;Select Subject:&quot;)&#10;                            ExposedDropdownMenuBox(&#10;                                expanded = subjectDropdownExpanded,&#10;                                onExpandedChange = { subjectDropdownExpanded = it }&#10;                            ) {&#10;                                OutlinedTextField(&#10;                                    value = selectedSubject,&#10;                                    onValueChange = {},&#10;                                    readOnly = true,&#10;                                    label = { Text(&quot;Subject&quot;) },&#10;                                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = subjectDropdownExpanded) },&#10;                                    modifier = Modifier.menuAnchor()&#10;                                )&#10;                                ExposedDropdownMenu(&#10;                                    expanded = subjectDropdownExpanded,&#10;                                    onDismissRequest = { subjectDropdownExpanded = false }&#10;                                ) {&#10;                                    subjectOptions.forEach { subj -&gt;&#10;                                        DropdownMenuItem(&#10;                                            text = { Text(subj) },&#10;                                            onClick = {&#10;                                                selectedSubject = subj&#10;                                                subjectDropdownExpanded = false&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&quot;Select Time Slots (≤20 min gap):&quot;)&#10;                            Box(modifier = Modifier.height(220.dp)) {&#10;                                LazyColumn {&#10;                                    items(slotEntities.sortedBy { LocalTime.parse(it.startTime, timeFormatter) }) { slot -&gt;&#10;                                        val checked = selectedSlotIds.contains(slot.id)&#10;                                        Button(&#10;                                            onClick = {&#10;                                                if (!checked) {&#10;                                                    val allSelected = selectedSlotIds + slot.id&#10;                                                    val sortedSlots = slotEntities.filter { allSelected.contains(it.id) }&#10;                                                        .sortedBy { LocalTime.parse(it.startTime, timeFormatter) }&#10;                                                    val valid = sortedSlots.zipWithNext().all { (a, b) -&gt;&#10;                                                        val aEnd = LocalTime.parse(a.endTime, timeFormatter)&#10;                                                        val bStart = LocalTime.parse(b.startTime, timeFormatter)&#10;                                                        java.time.Duration.between(aEnd, bStart).toMinutes() &lt;= 20&#10;                                                    }&#10;                                                    if (valid) {&#10;                                                        selectedSlotIds.add(slot.id)&#10;                                                        slotSelectionError = null&#10;                                                    } else {&#10;                                                        slotSelectionError = &quot;Selected slots must be consecutive with ≤20 min gap.&quot;&#10;                                                    }&#10;                                                } else {&#10;                                                    selectedSlotIds.remove(slot.id)&#10;                                                    slotSelectionError = null&#10;                                                }&#10;                                            },&#10;                                            colors = ButtonDefaults.buttonColors(&#10;                                                containerColor = if (checked) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.surface,&#10;                                                contentColor = if (checked) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface&#10;                                            ),&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .padding(vertical = 4.dp)&#10;                                        ) {&#10;                                            Text(&quot;${slot.label}: ${slot.startTime} - ${slot.endTime}&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                            if (slotSelectionError != null) {&#10;                                Text(slotSelectionError!!, color = MaterialTheme.colorScheme.error)&#10;                            }&#10;                            if (!errorMessage.isNullOrBlank()) {&#10;                                LaunchedEffect(errorMessage) {&#10;                                }&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(vertical = 8.dp)&#10;                                        .background(&#10;                                            color = MaterialTheme.colorScheme.error.copy(alpha = 0.1f),&#10;                                            shape = MaterialTheme.shapes.medium&#10;                                        )&#10;                                        .padding(12.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Filled.Error,&#10;                                        contentDescription = &quot;Error&quot;,&#10;                                        tint = MaterialTheme.colorScheme.error,&#10;                                        modifier = Modifier.size(24.dp)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(8.dp))&#10;                                    Text(&#10;                                        text = errorMessage!!,&#10;                                        color = MaterialTheme.colorScheme.error,&#10;                                        style = MaterialTheme.typography.bodyMedium,&#10;                                        modifier = Modifier.weight(1f)&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Update LocalTime.parse calls to trim input strings and handle errors&#10;val safeParseTime: (String) -&gt; LocalTime? = { timeString -&gt;&#10;    try {&#10;        val trimmedTime = timeString.trim()&#10;        println(&quot;Parsing time: '$trimmedTime'&quot;) // Debugging log&#10;        LocalTime.parse(trimmedTime, timeFormatter)&#10;    } catch (e: DateTimeParseException) {&#10;        println(&quot;Failed to parse time: '${timeString.trim()}' - ${e.message}&quot;) // Debugging log&#10;        null&#10;    }&#10;}&#10;&#10;// Enhanced time parsing with fallback and added debugging logs&#10;fun parseTimeWithFallback(timeString: String, defaultHour: Int, defaultMinute: Int): LocalTime {&#10;    return try {&#10;        val trimmedTime = timeString.trim()&#10;        println(&quot;Parsing time with fallback: '$trimmedTime'&quot;) // Debugging log&#10;        LocalTime.parse(trimmedTime, timeFormatter)&#10;    } catch (e: Exception) {&#10;        println(&quot;Failed to parse time with fallback: '$timeString' - ${e.message}&quot;) // Debugging log&#10;        LocalTime.of(defaultHour, defaultMinute)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.attendance_tracker.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.foundation.background&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.Error&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.unit.dp&#10;import com.example.attendance_tracker.ui.components.CustomDismissValue&#10;import java.time.format.DateTimeParseException&#10;import kotlinx.coroutines.launch&#10;import com.example.attendance_tracker.viewmodel.TimetableViewModel&#10;import com.example.attendance_tracker.data.TimetableEntry&#10;import com.example.attendance_tracker.data.SubjectRepository&#10;import com.example.attendance_tracker.viewmodel.CommonSlotViewModel&#10;import com.example.attendance_tracker.viewmodel.AttendanceViewModel&#10;import com.example.attendance_tracker.data.AttendanceStatus&#10;import java.time.LocalDate&#10;import java.time.format.TextStyle&#10;import java.util.Locale&#10;import java.time.LocalTime&#10;import java.time.format.DateTimeFormatter&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import com.example.attendance_tracker.ui.components.*&#10;&#10;// Define a single DateTimeFormatter instance for reuse&#10;val timeFormatter = DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US)&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun HomeScreen(&#10;    timetableViewModel: TimetableViewModel,&#10;    subjectRepository: SubjectRepository,&#10;    commonSlotViewModel: CommonSlotViewModel = androidx.lifecycle.viewmodel.compose.viewModel(),&#10;    attendanceViewModel: AttendanceViewModel&#10;) {&#10;    val today = LocalDate.now().dayOfWeek.getDisplayName(TextStyle.FULL, Locale.US)&#10;    val timetableEntries by timetableViewModel.getEntriesForDay(today).collectAsState()&#10;    var showDialog by remember { mutableStateOf(false) }&#10;    var editingEntry by remember { mutableStateOf&lt;TimetableEntry?&gt;(null) }&#10;    var subject by remember { mutableStateOf(&quot;&quot;) }&#10;    val subjects by subjectRepository.allSubjects.collectAsState(initial = emptyList())&#10;    val slotEntities by commonSlotViewModel.slots.collectAsState()&#10;    var selectedSlotLabel by remember { mutableStateOf(&quot;&quot;) }&#10;    var startTime by remember { mutableStateOf(&quot;&quot;) }&#10;    var endTime by remember { mutableStateOf(&quot;&quot;) }&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val todayDate = LocalDate.now()&#10;    val dayOfWeek = todayDate.dayOfWeek.getDisplayName(TextStyle.FULL, Locale.US)&#10;    val dateStr = todayDate.format(java.time.format.DateTimeFormatter.ofPattern(&quot;dd MMMM yyyy&quot;))&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Today - $dayOfWeek's Timetable&quot;) },&#10;                actions = {&#10;                    IconButton(onClick = {&#10;                        editingEntry = null&#10;                        subject = &quot;&quot;&#10;                        startTime = &quot;&quot;&#10;                        endTime = &quot;&quot;&#10;                        selectedSlotLabel = &quot;&quot;&#10;                        showDialog = true&#10;                    }) {&#10;                        Icon(Icons.Filled.Add, contentDescription = &quot;Add Timetable Entry&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Box(modifier = Modifier.fillMaxSize().padding(innerPadding)) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(text = dateStr, style = MaterialTheme.typography.titleMedium)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;            }&#10;            if (timetableEntries.isEmpty()) {&#10;                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;                    Text(&quot;No timetable entries for today.&quot;)&#10;                }&#10;            } else {&#10;                LazyColumn(modifier = Modifier.fillMaxSize()) {&#10;                    items(timetableEntries) { entry -&gt;&#10;                        // Find the slot(s) for this entry&#10;                        val entrySlots = slotEntities.filter {&#10;                            (safeParseTime(it.startTime) ?: LocalTime.MIN) &gt;= (safeParseTime(entry.startTime) ?: LocalTime.MIN) &amp;&amp;&#10;                                    (safeParseTime(it.endTime) ?: LocalTime.MAX) &lt;= (safeParseTime(entry.endTime) ?: LocalTime.MAX)&#10;                        }&#10;                        val selectedSlots: List&lt;Int&gt; = entrySlots.map { it.id }&#10;                        val dismissState = rememberCustomDismissState()&#10;                        // Overlap prevention logic&#10;                        val isOverlapping = slotEntities.any { slot -&gt;&#10;                            slot.id != entry.id &amp;&amp;&#10;                            (safeParseTime(slot.startTime)?.isBefore(safeParseTime(entry.endTime)) == true &amp;&amp;&#10;                             safeParseTime(slot.endTime)?.isAfter(safeParseTime(entry.startTime)) == true)&#10;                        }&#10;                        if (isOverlapping) {&#10;                            errorMessage = &quot;Time slot overlaps with another entry!&quot;&#10;                        } else {&#10;                            errorMessage = null&#10;                        }&#10;                        if (dismissState.value == CustomDismissValue.DismissedToEnd || dismissState.value == CustomDismissValue.DismissedToStart) {&#10;                            val subjectId = subjects.find { it.name == entry.subject }?.id ?: 0&#10;                            LaunchedEffect(dismissState.value) {&#10;                                val attendance = attendanceViewModel.getAttendanceStatusForSubjectOnDate(subjectId, todayDate.toString())&#10;                                if (attendance == null) {&#10;                                    // No record yet, insert new&#10;                                    attendanceViewModel.markAttendance(&#10;                                        subjectId = subjectId,&#10;                                        selectedSlots = selectedSlots,&#10;                                        date = todayDate.toString(),&#10;                                        status = if (dismissState.value == CustomDismissValue.DismissedToEnd) AttendanceStatus.PRESENT else AttendanceStatus.ABSENT&#10;                                    )&#10;                                } else {&#10;                                    // Record exists, update status&#10;                                    attendanceViewModel.updateAttendanceStatusForSubjectOnDate(&#10;                                        subjectId,&#10;                                        todayDate.toString(),&#10;                                        if (dismissState.value == CustomDismissValue.DismissedToEnd) AttendanceStatus.PRESENT else AttendanceStatus.ABSENT&#10;                                    )&#10;                                }&#10;                                errorMessage = if (dismissState.value == CustomDismissValue.DismissedToEnd) {&#10;                                    &quot;Marked Present for ${entry.subject}&quot;&#10;                                } else {&#10;                                    &quot;Marked Absent for ${entry.subject}&quot;&#10;                                }&#10;                                dismissState.value = CustomDismissValue.Default&#10;                            }&#10;                        }&#10;                        CustomSwipeToDismiss(&#10;                            state = dismissState,&#10;                            background = { direction -&gt;&#10;                                val color = when (direction) {&#10;                                    CustomDismissDirection.StartToEnd -&gt; MaterialTheme.colorScheme.primary&#10;                                    CustomDismissDirection.EndToStart -&gt; MaterialTheme.colorScheme.error&#10;                                }&#10;                                Box(&#10;                                    Modifier&#10;                                        .fillMaxSize()&#10;                                        .background(color)&#10;                                )&#10;                            },&#10;                            content = {&#10;                                val subjectId = subjects.find { it.name == entry.subject }?.id&#10;                                // Use attendance status as a State from ViewModel for instant updates&#10;                                val attendanceStatusState = attendanceViewModel.getAttendanceStatusFlow(subjectId, todayDate.toString()).collectAsState(initial = null)&#10;                                val attendanceStatus = attendanceStatusState.value&#10;                                Card(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(8.dp),&#10;                                    elevation = CardDefaults.cardElevation(2.dp),&#10;                                    colors = CardDefaults.cardColors(&#10;                                        containerColor = when (attendanceStatus) {&#10;                                            AttendanceStatus.PRESENT -&gt; Color(0xFFA5D6A7)&#10;                                            AttendanceStatus.ABSENT -&gt; Color(0xFFEF9A9A)&#10;                                            null -&gt; MaterialTheme.colorScheme.surface&#10;                                            else -&gt; MaterialTheme.colorScheme.surface&#10;                                        }&#10;                                    )&#10;                                ) {&#10;                                    Column(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .padding(16.dp)&#10;                                    ) {&#10;                                        Text(entry.subject, style = MaterialTheme.typography.titleMedium)&#10;                                        Text(&quot;${entry.startTime} - ${entry.endTime}&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                        // --- Attendance Progress Bar ---&#10;                                        val subjectObj = subjects.find { it.name == entry.subject }&#10;                                        val attended = subjectObj?.attendedClasses ?: 0&#10;                                        val total = subjectObj?.totalClasses ?: 0&#10;                                        val threshold = subjectObj?.threshold ?: 75&#10;                                        val attendancePercent = if (total &gt; 0) attended * 100 / total else 0&#10;                                        val thresholdPercent = threshold&#10;                                        Spacer(modifier = Modifier.height(8.dp))&#10;                                        Box(modifier = Modifier.fillMaxWidth().height(20.dp)) {&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxSize()&#10;                                                    .background(MaterialTheme.colorScheme.secondary.copy(alpha = 0.5f))&#10;                                            )&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxHeight()&#10;                                                    .fillMaxWidth(fraction = thresholdPercent / 100f)&#10;                                                    .background(MaterialTheme.colorScheme.error.copy(alpha = 0.75f))&#10;                                            )&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxHeight()&#10;                                                    .fillMaxWidth(fraction = attendancePercent / 100f)&#10;                                                    .background(MaterialTheme.colorScheme.primary)&#10;                                            )&#10;                                        }&#10;                                        Spacer(modifier = Modifier.height(2.dp))&#10;                                        Row(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.SpaceBetween&#10;                                        ) {&#10;                                            Text(&quot;Attendance: $attendancePercent%&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                            Text(&quot;Threshold: $thresholdPercent%&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                        }&#10;                                        // --- Edit/Delete Controls ---&#10;                                        Row(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.End&#10;                                        ) {&#10;                                            IconButton(onClick = {&#10;                                                editingEntry = entry&#10;                                                subject = entry.subject&#10;                                                startTime = entry.startTime&#10;                                                endTime = entry.endTime&#10;                                                showDialog = true&#10;                                            }) {&#10;                                                Icon(Icons.Filled.Edit, contentDescription = &quot;Edit&quot;)&#10;                                            }&#10;                                            IconButton(onClick = {&#10;                                                coroutineScope.launch {&#10;                                                    timetableViewModel.deleteEntry(entry)&#10;                                                    errorMessage = &quot;Entry deleted&quot;&#10;                                                }&#10;                                            }) {&#10;                                                Icon(Icons.Filled.Delete, contentDescription = &quot;Delete&quot;)&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (showDialog) {&#10;                var subjectDropdownExpanded by remember { mutableStateOf(false) }&#10;                val subjectOptions = subjects.map { it.name }&#10;                var selectedSubject by remember { mutableStateOf(subjectOptions.firstOrNull() ?: &quot;&quot;) }&#10;                val selectedSlotIds = remember { mutableStateListOf&lt;Int&gt;() }&#10;                var slotSelectionError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;                // Reset errorMessage when subject or slot selection changes&#10;                LaunchedEffect(selectedSubject, selectedSlotIds) {&#10;                    errorMessage = null&#10;                }&#10;&#10;                AlertDialog(&#10;                    onDismissRequest = { showDialog = false },&#10;                    confirmButton = {&#10;                        Button(onClick = {&#10;                            if (selectedSubject.isBlank() || selectedSlotIds.isEmpty() || slotSelectionError != null) {&#10;                                errorMessage = slotSelectionError ?: &quot;Please select subject and valid slots.&quot;&#10;                                return@Button&#10;                            }&#10;                            val selectedSlots = slotEntities.filter { selectedSlotIds.contains(it.id) }&#10;                                .sortedBy { LocalTime.parse(it.startTime, timeFormatter) }&#10;                            val newStart = LocalTime.parse(selectedSlots.first().startTime, timeFormatter)&#10;                            val newEnd = LocalTime.parse(selectedSlots.last().endTime, timeFormatter)&#10;                            val conflict = timetableEntries.any { entry -&gt;&#10;                                if (editingEntry != null &amp;&amp; entry.id == editingEntry!!.id) return@any false // skip self when editing&#10;                                val entryStart = LocalTime.parse(entry.startTime, timeFormatter)&#10;                                val entryEnd = LocalTime.parse(entry.endTime, timeFormatter)&#10;                                val timeOverlap = newStart &lt; entryEnd &amp;&amp; newEnd &gt; entryStart&#10;                                val slotOverlap = entry.slotIds.any { selectedSlotIds.contains(it) }&#10;                                timeOverlap || slotOverlap&#10;                            }&#10;                            if (conflict) {&#10;                                errorMessage = &quot;Conflict: Overlapping time or duplicate slot with another entry.&quot;&#10;                                return@Button&#10;                            }&#10;                            coroutineScope.launch {&#10;                                val startStr = selectedSlots.first().startTime&#10;                                val endStr = selectedSlots.last().endTime&#10;                                if (editingEntry == null) {&#10;                                    timetableViewModel.addEntry(&#10;                                        TimetableEntry(&#10;                                            dayOfWeek = today ,&#10;                                            subject = selectedSubject,&#10;                                            startTime = startStr,&#10;                                            endTime = endStr,&#10;                                            slotIds = selectedSlotIds.toList()&#10;                                        )&#10;                                    )&#10;                                    errorMessage = &quot;Entry added&quot;&#10;                                } else {&#10;                                    timetableViewModel.deleteEntry(editingEntry!!)&#10;                                    timetableViewModel.addEntry(&#10;                                        TimetableEntry(&#10;                                            id = editingEntry!!.id,&#10;                                            dayOfWeek = today ,&#10;                                            subject = selectedSubject,&#10;                                            startTime = startStr,&#10;                                            endTime = endStr,&#10;                                            slotIds = selectedSlotIds.toList()&#10;                                        )&#10;                                    )&#10;                                    errorMessage = &quot;Entry updated&quot;&#10;                                }&#10;                                showDialog = false&#10;                            }&#10;                        }) {&#10;                            Text(&quot;Save&quot;)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        OutlinedButton(onClick = { showDialog = false }) {&#10;                            Text(&quot;Cancel&quot;)&#10;                        }&#10;                    },&#10;                    title = { Text(if (editingEntry == null) &quot;Add Timetable Entry&quot; else &quot;Edit Timetable Entry&quot;) },&#10;                    text = {&#10;                        Column {&#10;                            Text(&quot;Select Subject:&quot;)&#10;                            ExposedDropdownMenuBox(&#10;                                expanded = subjectDropdownExpanded,&#10;                                onExpandedChange = { subjectDropdownExpanded = it }&#10;                            ) {&#10;                                OutlinedTextField(&#10;                                    value = selectedSubject,&#10;                                    onValueChange = {},&#10;                                    readOnly = true,&#10;                                    label = { Text(&quot;Subject&quot;) },&#10;                                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = subjectDropdownExpanded) },&#10;                                    modifier = Modifier.menuAnchor()&#10;                                )&#10;                                ExposedDropdownMenu(&#10;                                    expanded = subjectDropdownExpanded,&#10;                                    onDismissRequest = { subjectDropdownExpanded = false }&#10;                                ) {&#10;                                    subjectOptions.forEach { subj -&gt;&#10;                                        DropdownMenuItem(&#10;                                            text = { Text(subj) },&#10;                                            onClick = {&#10;                                                selectedSubject = subj&#10;                                                subjectDropdownExpanded = false&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&quot;Select Time Slots (≤20 min gap):&quot;)&#10;                            Box(modifier = Modifier.height(220.dp)) {&#10;                                LazyColumn {&#10;                                    items(slotEntities.sortedBy { LocalTime.parse(it.startTime, timeFormatter) }) { slot -&gt;&#10;                                        val checked = selectedSlotIds.contains(slot.id)&#10;                                        Button(&#10;                                            onClick = {&#10;                                                if (!checked) {&#10;                                                    val allSelected = selectedSlotIds + slot.id&#10;                                                    val sortedSlots = slotEntities.filter { allSelected.contains(it.id) }&#10;                                                        .sortedBy { LocalTime.parse(it.startTime, timeFormatter) }&#10;                                                    val valid = sortedSlots.zipWithNext().all { (a, b) -&gt;&#10;                                                        val aEnd = LocalTime.parse(a.endTime, timeFormatter)&#10;                                                        val bStart = LocalTime.parse(b.startTime, timeFormatter)&#10;                                                        java.time.Duration.between(aEnd, bStart).toMinutes() &lt;= 20&#10;                                                    }&#10;                                                    if (valid) {&#10;                                                        selectedSlotIds.add(slot.id)&#10;                                                        slotSelectionError = null&#10;                                                    } else {&#10;                                                        slotSelectionError = &quot;Selected slots must be consecutive with ≤20 min gap.&quot;&#10;                                                    }&#10;                                                } else {&#10;                                                    selectedSlotIds.remove(slot.id)&#10;                                                    slotSelectionError = null&#10;                                                }&#10;                                            },&#10;                                            colors = ButtonDefaults.buttonColors(&#10;                                                containerColor = if (checked) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.surface,&#10;                                                contentColor = if (checked) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface&#10;                                            ),&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .padding(vertical = 4.dp)&#10;                                        ) {&#10;                                            Text(&quot;${slot.label}: ${slot.startTime} - ${slot.endTime}&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                            if (slotSelectionError != null) {&#10;                                Text(slotSelectionError!!, color = MaterialTheme.colorScheme.error)&#10;                            }&#10;                            if (!errorMessage.isNullOrBlank()) {&#10;                                LaunchedEffect(errorMessage) {&#10;                                }&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(vertical = 8.dp)&#10;                                        .background(&#10;                                            color = MaterialTheme.colorScheme.error.copy(alpha = 0.1f),&#10;                                            shape = MaterialTheme.shapes.medium&#10;                                        )&#10;                                        .padding(12.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Filled.Error,&#10;                                        contentDescription = &quot;Error&quot;,&#10;                                        tint = MaterialTheme.colorScheme.error,&#10;                                        modifier = Modifier.size(24.dp)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(8.dp))&#10;                                    Text(&#10;                                        text = errorMessage!!,&#10;                                        color = MaterialTheme.colorScheme.error,&#10;                                        style = MaterialTheme.typography.bodyMedium,&#10;                                        modifier = Modifier.weight(1f)&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Update LocalTime.parse calls to trim input strings and handle errors&#10;val safeParseTime: (String) -&gt; LocalTime? = { timeString -&gt;&#10;    try {&#10;        val trimmedTime = timeString.trim()&#10;        println(&quot;Parsing time: '$trimmedTime'&quot;) // Debugging log&#10;        LocalTime.parse(trimmedTime, timeFormatter)&#10;    } catch (e: DateTimeParseException) {&#10;        println(&quot;Failed to parse time: '${timeString.trim()}' - ${e.message}&quot;) // Debugging log&#10;        null&#10;    }&#10;}&#10;&#10;// Enhanced time parsing with fallback and added debugging logs&#10;fun parseTimeWithFallback(timeString: String, defaultHour: Int, defaultMinute: Int): LocalTime {&#10;    return try {&#10;        val trimmedTime = timeString.trim()&#10;        println(&quot;Parsing time with fallback: '$trimmedTime'&quot;) // Debugging log&#10;        LocalTime.parse(trimmedTime, timeFormatter)&#10;    } catch (e: Exception) {&#10;        println(&quot;Failed to parse time with fallback: '$timeString' - ${e.message}&quot;) // Debugging log&#10;        LocalTime.of(defaultHour, defaultMinute)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/ui/screens/SubjectsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/ui/screens/SubjectsScreen.kt" />
              <option name="originalContent" value="package com.example.attendance_tracker.ui.screens&#10;&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.attendance_tracker.data.*&#10;import com.example.attendance_tracker.ui.components.AddOrEditSubjectDialog&#10;import com.example.attendance_tracker.viewmodel.SubjectViewModel&#10;import com.example.attendance_tracker.viewmodel.SubjectViewModelFactory&#10;import com.example.attendance_tracker.viewmodel.AttendanceViewModel&#10;import kotlinx.coroutines.launch&#10;import java.time.LocalDate&#10;import java.time.format.DateTimeFormatter&#10;import java.util.Locale&#10;import org.apache.poi.xssf.usermodel.XSSFWorkbook&#10;import org.apache.poi.ss.usermodel.CellType&#10;import org.apache.poi.ss.usermodel.Row&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SubjectsScreen(&#10;    repository: SubjectRepository,&#10;    attendanceViewModel: AttendanceViewModel&#10;) {&#10;    val context = LocalContext.current&#10;    val viewModel: SubjectViewModel = viewModel(factory = SubjectViewModelFactory(repository))&#10;    val subjects by viewModel.subjects.collectAsState()&#10;    var showDialog by remember { mutableStateOf(false) }&#10;    var showEditDialog by remember { mutableStateOf(false) }&#10;    var editingSubject by remember { mutableStateOf&lt;Subject?&gt;(null) }&#10;    var attendedClasses by remember { mutableStateOf(0) }&#10;    var totalClasses by remember { mutableStateOf(0) }&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val dateFormatter = DateTimeFormatter.ofPattern(&quot;dd-MM-yyyy&quot;, Locale.getDefault())&#10;    val today = LocalDate.now().format(dateFormatter)&#10;&#10;    // Search bar state&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    val filteredSubjects = subjects.filter { it.name.contains(searchQuery, ignoreCase = true) }&#10;&#10;    LaunchedEffect(errorMessage) {&#10;        errorMessage?.let {&#10;            snackbarHostState.showSnackbar(it)&#10;            errorMessage = null&#10;        }&#10;    }&#10;&#10;    // Export launcher (must be inside composable)&#10;    val exportLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.CreateDocument(&quot;text/csv&quot;),&#10;        onResult = { uri: android.net.Uri? -&gt;&#10;            if (uri != null) {&#10;                coroutineScope.launch {&#10;                    val csv = buildCsv(filteredSubjects)&#10;                    context.contentResolver.openOutputStream(uri)?.use { it.write(csv.toByteArray()) }&#10;                }&#10;            }&#10;        }&#10;    )&#10;&#10;    // Export launcher for Excel&#10;    val exportExcelLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.CreateDocument(&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;),&#10;        onResult = { uri: android.net.Uri? -&gt;&#10;            if (uri != null) {&#10;                coroutineScope.launch {&#10;                    val excelBytes = buildExcel(filteredSubjects)&#10;                    context.contentResolver.openOutputStream(uri)?.use { it.write(excelBytes) }&#10;                }&#10;            }&#10;        }&#10;    )&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Subjects&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = { /* Handle back navigation */ }) {&#10;                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;Back&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    IconButton(onClick = {&#10;                        editingSubject = null&#10;                        showDialog = true&#10;                    }) {&#10;                        Icon(Icons.Default.Add, contentDescription = &quot;Add Subject&quot;)&#10;                    }&#10;                    IconButton(onClick = {&#10;                        exportLauncher.launch(&quot;attendance_export_${LocalDate.now()}.csv&quot;)&#10;                    }) {&#10;                        Icon(Icons.Default.Delete, contentDescription = &quot;Export&quot;)&#10;                    }&#10;                    IconButton(onClick = {&#10;                        exportExcelLauncher.launch(&quot;attendance_export_${LocalDate.now()}.xlsx&quot;)&#10;                    }) {&#10;                        Icon(Icons.Default.Add, contentDescription = &quot;Export to Excel&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Column(modifier = Modifier.fillMaxSize().padding(innerPadding)) {&#10;            // Search bar&#10;            OutlinedTextField(&#10;                value = searchQuery,&#10;                onValueChange = { searchQuery = it },&#10;                label = { Text(&quot;Search Subjects&quot;) },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(8.dp),&#10;                shape = MaterialTheme.shapes.medium, // Rounded rectangle shape&#10;                singleLine = true // Single-line input for a sleek look&#10;            )&#10;&#10;            if (filteredSubjects.isEmpty()) {&#10;                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;                    Text(&quot;No subjects found.&quot;)&#10;                }&#10;            } else {&#10;                LazyColumn(modifier = Modifier.fillMaxSize()) {&#10;                    items(filteredSubjects) { subject -&gt;&#10;                        SubjectCard(&#10;                            subject = subject,&#10;                            viewModel = viewModel,&#10;                            attendanceViewModel = attendanceViewModel,&#10;                            today = today,&#10;                            attendanceHistory = attendanceViewModel.attendanceHistory.collectAsState().value,&#10;                            onEdit = {&#10;                                editingSubject = subject&#10;                                showDialog = true&#10;                            },&#10;                            onDeleteSuccess = { msg -&gt; errorMessage = msg },&#10;                            onEditAttendance = {&#10;                                editingSubject = subject&#10;                                attendedClasses = subject.attendedClasses&#10;                                totalClasses = subject.totalClasses&#10;                                showEditDialog = true&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (showDialog) {&#10;                AddOrEditSubjectDialog(&#10;                    initialSubject = editingSubject,&#10;                    onAdd = { name, type, threshold -&gt;&#10;                        coroutineScope.launch {&#10;                            val trimmedName = name.trim()&#10;                            when {&#10;                                trimmedName.isEmpty() -&gt; errorMessage = &quot;Name cannot be empty.&quot;&#10;                                subjects.any { it.name.equals(trimmedName, ignoreCase = true) } -&gt; errorMessage = &quot;Subject with this name already exists.&quot;&#10;                                else -&gt; try {&#10;                                    viewModel.addSubject(Subject(name = trimmedName, type = type, threshold = threshold))&#10;                                    showDialog = false&#10;                                    errorMessage = &quot;Subject added&quot;&#10;                                } catch (e: Exception) {&#10;                                    errorMessage = &quot;Failed to add subject&quot;&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onUpdate = { updatedSubject -&gt;&#10;                        coroutineScope.launch {&#10;                            val trimmedName = updatedSubject.name.trim()&#10;                            if (trimmedName.isEmpty() ||&#10;                                subjects.any { it.name.equals(trimmedName, ignoreCase = true) &amp;&amp; it.id != updatedSubject.id }) {&#10;                                errorMessage = &quot;Another subject with this name already exists.&quot;&#10;                            } else {&#10;                                try {&#10;                                    viewModel.updateSubject(updatedSubject.copy(name = trimmedName))&#10;                                    showDialog = false&#10;                                    errorMessage = &quot;Subject updated&quot;&#10;                                } catch (e: Exception) {&#10;                                    errorMessage = &quot;Failed to update subject&quot;&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onDismiss = { showDialog = false }&#10;                )&#10;            }&#10;&#10;            if (showEditDialog &amp;&amp; editingSubject != null) {&#10;                AlertDialog(&#10;                    onDismissRequest = { showEditDialog = false },&#10;                    title = { Text(&quot;Edit Attendance for ${editingSubject!!.name}&quot;) },&#10;                    text = {&#10;                        Column {&#10;                            OutlinedTextField(&#10;                                value = attendedClasses.toString(),&#10;                                onValueChange = { attendedClasses = it.toIntOrNull() ?: 0 },&#10;                                label = { Text(&quot;Attended Classes&quot;) }&#10;                            )&#10;                            OutlinedTextField(&#10;                                value = totalClasses.toString(),&#10;                                onValueChange = { totalClasses = it.toIntOrNull() ?: 0 },&#10;                                label = { Text(&quot;Total Classes&quot;) }&#10;                            )&#10;                        }&#10;                    },&#10;                    confirmButton = {&#10;                        Button(onClick = {&#10;                            coroutineScope.launch {&#10;                                attendanceViewModel.updateManualAttendance(&#10;                                    editingSubject!!.id,&#10;                                    attendedClasses,&#10;                                    totalClasses,&#10;                                    note = &quot;Manual record updated&quot;,&#10;                                    date = today&#10;                                )&#10;                                errorMessage = &quot;Attendance record updated manually&quot;&#10;                            }&#10;                            showEditDialog = false&#10;                        }) {&#10;                            Text(&quot;Save&quot;)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        Button(onClick = { showEditDialog = false }) {&#10;                            Text(&quot;Cancel&quot;)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SubjectCard(&#10;    subject: Subject,&#10;    viewModel: SubjectViewModel,&#10;    attendanceViewModel: AttendanceViewModel,&#10;    today: String,&#10;    attendanceHistory: List&lt;Attendance&gt;, // Explicitly typed&#10;    onEdit: () -&gt; Unit,&#10;    onDeleteSuccess: (String) -&gt; Unit,&#10;    onEditAttendance: () -&gt; Unit&#10;) {&#10;    val attendancePercentage = if (subject.totalClasses &gt; 0) {&#10;        subject.attendedClasses * 100.0 / subject.totalClasses&#10;    } else {&#10;        0.0&#10;    }&#10;    val localCoroutineScope = rememberCoroutineScope()&#10;&#10;    LaunchedEffect(subject.id) {&#10;        attendanceViewModel.loadAttendance(subject.id)&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(8.dp)&#10;            .clickable { onEdit() },&#10;        elevation = CardDefaults.cardElevation(2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(subject.name, style = MaterialTheme.typography.titleMedium)&#10;                    Text(subject.type, style = MaterialTheme.typography.bodyMedium)&#10;                    Text(&quot;Threshold: ${subject.threshold}%&quot;, style = MaterialTheme.typography.bodySmall)&#10;                    Text(&quot;Attended: ${subject.attendedClasses} / Total: ${subject.totalClasses}&quot;, style = MaterialTheme.typography.bodySmall)&#10;&#10;                    val attended = subject.attendedClasses&#10;                    val total = subject.totalClasses&#10;                    val threshold = subject.threshold&#10;                    val attendancePercent = if (total &gt; 0) attended * 100 / total else 0&#10;                    val thresholdPercent = threshold&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Box(modifier = Modifier.fillMaxWidth().height(20.dp)) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .background(MaterialTheme.colorScheme.secondary.copy(alpha = 0.5f))&#10;                        )&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxHeight()&#10;                                .fillMaxWidth(fraction = thresholdPercent / 100f)&#10;                                .background(MaterialTheme.colorScheme.error.copy(alpha = 0.75f))&#10;                        )&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxHeight()&#10;                                .fillMaxWidth(fraction = attendancePercent / 100f)&#10;                                .background(MaterialTheme.colorScheme.primary)&#10;                        )&#10;                    }&#10;                }&#10;                var showDeleteDialog by remember { mutableStateOf(false) }&#10;                IconButton(onClick = { showDeleteDialog = true }) {&#10;                    Icon(Icons.Default.Delete, contentDescription = &quot;Delete&quot;)&#10;                }&#10;                if (showDeleteDialog) {&#10;                    AlertDialog(&#10;                        onDismissRequest = { showDeleteDialog = false },&#10;                        title = { Text(&quot;Delete Subject&quot;) },&#10;                        text = { Text(&quot;Are you sure you want to delete this subject? This action cannot be undone.&quot;) },&#10;                        confirmButton = {&#10;                            Button(onClick = {&#10;                                showDeleteDialog = false&#10;                                localCoroutineScope.launch {&#10;                                    viewModel.deleteSubject(subject)&#10;                                    onDeleteSuccess(&quot;Subject deleted&quot;)&#10;                                }&#10;                            }) { Text(&quot;Delete&quot;) }&#10;                        },&#10;                        dismissButton = {&#10;                            Button(onClick = { showDeleteDialog = false }) { Text(&quot;Cancel&quot;) }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Text(&quot;Attendance: ${&quot;%.1f&quot;.format(attendancePercentage)}%&quot;, style = MaterialTheme.typography.bodyMedium)&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Text(&quot;History:&quot;, style = MaterialTheme.typography.titleSmall)&#10;            if (attendanceHistory.isEmpty()) {&#10;                Text(&quot;No attendance records yet.&quot;, style = MaterialTheme.typography.bodySmall)&#10;            } else {&#10;                attendanceHistory.take(5).forEach { record -&gt;&#10;                    val statusText = if (record.note != null &amp;&amp; record.note.contains(&quot;Manual record updated&quot;)) &quot;Updated&quot; else record.status.name&#10;                    Text(&quot;${record.date}: $statusText&quot;, style = MaterialTheme.typography.bodySmall)&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Button(onClick = onEditAttendance) {&#10;                Text(&quot;Edit Attendance&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;fun buildCsv(subjects: List&lt;Subject&gt;): String {&#10;    val header = &quot;Subject,Type,Threshold,Attended,Total,Percentage\n&quot;&#10;    val rows = subjects.joinToString(&quot;\n&quot;) {&#10;        val percentage = if (it.totalClasses &gt; 0) (it.attendedClasses * 100.0 / it.totalClasses) else 0.0&#10;        &quot;${it.name},${it.type},${it.threshold},${it.attendedClasses},${it.totalClasses},${&quot;%.2f&quot;.format(percentage)}&quot;&#10;    }&#10;    return header + rows&#10;}&#10;&#10;fun buildExcel(subjects: List&lt;Subject&gt;): ByteArray {&#10;    val workbook = XSSFWorkbook()&#10;    val sheet = workbook.createSheet(&quot;Attendance&quot;)&#10;    val header = listOf(&quot;Subject&quot;, &quot;Type&quot;, &quot;Threshold&quot;, &quot;Attended&quot;, &quot;Total&quot;, &quot;Percentage&quot;)&#10;    val headerRow = sheet.createRow(0)&#10;    header.forEachIndexed { idx, title -&gt;&#10;        val cell = headerRow.createCell(idx, CellType.STRING)&#10;        cell.setCellValue(title)&#10;    }&#10;    subjects.forEachIndexed { rowIdx, subject -&gt;&#10;        val row = sheet.createRow(rowIdx + 1)&#10;        row.createCell(0, CellType.STRING).setCellValue(subject.name)&#10;        row.createCell(1, CellType.STRING).setCellValue(subject.type)&#10;        row.createCell(2, CellType.NUMERIC).setCellValue(subject.threshold.toDouble())&#10;        row.createCell(3, CellType.NUMERIC).setCellValue(subject.attendedClasses.toDouble())&#10;        row.createCell(4, CellType.NUMERIC).setCellValue(subject.totalClasses.toDouble())&#10;        val percentage = if (subject.totalClasses &gt; 0) (subject.attendedClasses * 100.0 / subject.totalClasses) else 0.0&#10;        row.createCell(5, CellType.NUMERIC).setCellValue(percentage)&#10;    }&#10;    val out = java.io.ByteArrayOutputStream()&#10;    workbook.write(out)&#10;    workbook.close()&#10;    return out.toByteArray()&#10;" />
              <option name="updatedContent" value="package com.example.attendance_tracker.ui.screens&#10;&#10;import android.graphics.Paint&#10;import android.graphics.pdf.PdfDocument&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.attendance_tracker.data.*&#10;import com.example.attendance_tracker.ui.components.AddOrEditSubjectDialog&#10;import com.example.attendance_tracker.viewmodel.SubjectViewModel&#10;import com.example.attendance_tracker.viewmodel.SubjectViewModelFactory&#10;import com.example.attendance_tracker.viewmodel.AttendanceViewModel&#10;import kotlinx.coroutines.launch&#10;import java.time.LocalDate&#10;import java.time.format.DateTimeFormatter&#10;import java.util.Locale&#10;import org.apache.poi.xssf.usermodel.XSSFWorkbook&#10;import org.apache.poi.ss.usermodel.CellType&#10;import org.apache.poi.ss.usermodel.Row&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SubjectsScreen(&#10;    repository: SubjectRepository,&#10;    attendanceViewModel: AttendanceViewModel&#10;) {&#10;    val context = LocalContext.current&#10;    val viewModel: SubjectViewModel = viewModel(factory = SubjectViewModelFactory(repository))&#10;    val subjects by viewModel.subjects.collectAsState()&#10;    var showDialog by remember { mutableStateOf(false) }&#10;    var showEditDialog by remember { mutableStateOf(false) }&#10;    var editingSubject by remember { mutableStateOf&lt;Subject?&gt;(null) }&#10;    var attendedClasses by remember { mutableStateOf(0) }&#10;    var totalClasses by remember { mutableStateOf(0) }&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val dateFormatter = DateTimeFormatter.ofPattern(&quot;dd-MM-yyyy&quot;, Locale.getDefault())&#10;    val today = LocalDate.now().format(dateFormatter)&#10;&#10;    // Search bar state&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    val filteredSubjects = subjects.filter { it.name.contains(searchQuery, ignoreCase = true) }&#10;&#10;    LaunchedEffect(errorMessage) {&#10;        errorMessage?.let {&#10;            snackbarHostState.showSnackbar(it)&#10;            errorMessage = null&#10;        }&#10;    }&#10;&#10;    // Export launcher (must be inside composable)&#10;    val exportLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.CreateDocument(&quot;text/csv&quot;),&#10;        onResult = { uri: android.net.Uri? -&gt;&#10;            if (uri != null) {&#10;                coroutineScope.launch {&#10;                    val csv = buildCsv(filteredSubjects)&#10;                    context.contentResolver.openOutputStream(uri)?.use { it.write(csv.toByteArray()) }&#10;                }&#10;            }&#10;        }&#10;    )&#10;&#10;    // Export launcher for Excel&#10;    val exportExcelLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.CreateDocument(&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;),&#10;        onResult = { uri: android.net.Uri? -&gt;&#10;            if (uri != null) {&#10;                coroutineScope.launch {&#10;                    val excelBytes = buildExcel(filteredSubjects)&#10;                    context.contentResolver.openOutputStream(uri)?.use { it.write(excelBytes) }&#10;                }&#10;            }&#10;        }&#10;    )&#10;&#10;    // Export launcher for PDF&#10;    val exportPdfLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.CreateDocument(&quot;application/pdf&quot;),&#10;        onResult = { uri: android.net.Uri? -&gt;&#10;            if (uri != null) {&#10;                coroutineScope.launch {&#10;                    val pdfBytes = buildPdf(filteredSubjects)&#10;                    context.contentResolver.openOutputStream(uri)?.use { it.write(pdfBytes) }&#10;                }&#10;            }&#10;        }&#10;    )&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Subjects&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = { /* Handle back navigation */ }) {&#10;                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;Back&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    IconButton(onClick = {&#10;                        editingSubject = null&#10;                        showDialog = true&#10;                    }) {&#10;                        Icon(Icons.Default.Add, contentDescription = &quot;Add Subject&quot;)&#10;                    }&#10;                    IconButton(onClick = {&#10;                        exportLauncher.launch(&quot;attendance_export_${LocalDate.now()}.csv&quot;)&#10;                    }) {&#10;                        Icon(Icons.Default.Delete, contentDescription = &quot;Export&quot;)&#10;                    }&#10;                    IconButton(onClick = {&#10;                        exportExcelLauncher.launch(&quot;attendance_export_${LocalDate.now()}.xlsx&quot;)&#10;                    }) {&#10;                        Icon(Icons.Default.Add, contentDescription = &quot;Export to Excel&quot;)&#10;                    }&#10;                    IconButton(onClick = {&#10;                        exportPdfLauncher.launch(&quot;attendance_export_${LocalDate.now()}.pdf&quot;)&#10;                    }) {&#10;                        Icon(Icons.Default.Add, contentDescription = &quot;Export to PDF&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Column(modifier = Modifier.fillMaxSize().padding(innerPadding)) {&#10;            // Search bar&#10;            OutlinedTextField(&#10;                value = searchQuery,&#10;                onValueChange = { searchQuery = it },&#10;                label = { Text(&quot;Search Subjects&quot;) },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(8.dp),&#10;                shape = MaterialTheme.shapes.medium, // Rounded rectangle shape&#10;                singleLine = true // Single-line input for a sleek look&#10;            )&#10;&#10;            if (filteredSubjects.isEmpty()) {&#10;                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;                    Text(&quot;No subjects found.&quot;)&#10;                }&#10;            } else {&#10;                LazyColumn(modifier = Modifier.fillMaxSize()) {&#10;                    items(filteredSubjects) { subject -&gt;&#10;                        SubjectCard(&#10;                            subject = subject,&#10;                            viewModel = viewModel,&#10;                            attendanceViewModel = attendanceViewModel,&#10;                            today = today,&#10;                            attendanceHistory = attendanceViewModel.attendanceHistory.collectAsState().value,&#10;                            onEdit = {&#10;                                editingSubject = subject&#10;                                showDialog = true&#10;                            },&#10;                            onDeleteSuccess = { msg -&gt; errorMessage = msg },&#10;                            onEditAttendance = {&#10;                                editingSubject = subject&#10;                                attendedClasses = subject.attendedClasses&#10;                                totalClasses = subject.totalClasses&#10;                                showEditDialog = true&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (showDialog) {&#10;                AddOrEditSubjectDialog(&#10;                    initialSubject = editingSubject,&#10;                    onAdd = { name, type, threshold -&gt;&#10;                        coroutineScope.launch {&#10;                            val trimmedName = name.trim()&#10;                            when {&#10;                                trimmedName.isEmpty() -&gt; errorMessage = &quot;Name cannot be empty.&quot;&#10;                                subjects.any { it.name.equals(trimmedName, ignoreCase = true) } -&gt; errorMessage = &quot;Subject with this name already exists.&quot;&#10;                                else -&gt; try {&#10;                                    viewModel.addSubject(Subject(name = trimmedName, type = type, threshold = threshold))&#10;                                    showDialog = false&#10;                                    errorMessage = &quot;Subject added&quot;&#10;                                } catch (e: Exception) {&#10;                                    errorMessage = &quot;Failed to add subject&quot;&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onUpdate = { updatedSubject -&gt;&#10;                        coroutineScope.launch {&#10;                            val trimmedName = updatedSubject.name.trim()&#10;                            if (trimmedName.isEmpty() ||&#10;                                subjects.any { it.name.equals(trimmedName, ignoreCase = true) &amp;&amp; it.id != updatedSubject.id }) {&#10;                                errorMessage = &quot;Another subject with this name already exists.&quot;&#10;                            } else {&#10;                                try {&#10;                                    viewModel.updateSubject(updatedSubject.copy(name = trimmedName))&#10;                                    showDialog = false&#10;                                    errorMessage = &quot;Subject updated&quot;&#10;                                } catch (e: Exception) {&#10;                                    errorMessage = &quot;Failed to update subject&quot;&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onDismiss = { showDialog = false }&#10;                )&#10;            }&#10;&#10;            if (showEditDialog &amp;&amp; editingSubject != null) {&#10;                AlertDialog(&#10;                    onDismissRequest = { showEditDialog = false },&#10;                    title = { Text(&quot;Edit Attendance for ${editingSubject!!.name}&quot;) },&#10;                    text = {&#10;                        Column {&#10;                            OutlinedTextField(&#10;                                value = attendedClasses.toString(),&#10;                                onValueChange = { attendedClasses = it.toIntOrNull() ?: 0 },&#10;                                label = { Text(&quot;Attended Classes&quot;) }&#10;                            )&#10;                            OutlinedTextField(&#10;                                value = totalClasses.toString(),&#10;                                onValueChange = { totalClasses = it.toIntOrNull() ?: 0 },&#10;                                label = { Text(&quot;Total Classes&quot;) }&#10;                            )&#10;                        }&#10;                    },&#10;                    confirmButton = {&#10;                        Button(onClick = {&#10;                            coroutineScope.launch {&#10;                                attendanceViewModel.updateManualAttendance(&#10;                                    editingSubject!!.id,&#10;                                    attendedClasses,&#10;                                    totalClasses,&#10;                                    note = &quot;Manual record updated&quot;,&#10;                                    date = today&#10;                                )&#10;                                errorMessage = &quot;Attendance record updated manually&quot;&#10;                            }&#10;                            showEditDialog = false&#10;                        }) {&#10;                            Text(&quot;Save&quot;)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        Button(onClick = { showEditDialog = false }) {&#10;                            Text(&quot;Cancel&quot;)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SubjectCard(&#10;    subject: Subject,&#10;    viewModel: SubjectViewModel,&#10;    attendanceViewModel: AttendanceViewModel,&#10;    today: String,&#10;    attendanceHistory: List&lt;Attendance&gt;, // Explicitly typed&#10;    onEdit: () -&gt; Unit,&#10;    onDeleteSuccess: (String) -&gt; Unit,&#10;    onEditAttendance: () -&gt; Unit&#10;) {&#10;    val attendancePercentage = if (subject.totalClasses &gt; 0) {&#10;        subject.attendedClasses * 100.0 / subject.totalClasses&#10;    } else {&#10;        0.0&#10;    }&#10;    val localCoroutineScope = rememberCoroutineScope()&#10;&#10;    LaunchedEffect(subject.id) {&#10;        attendanceViewModel.loadAttendance(subject.id)&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(8.dp)&#10;            .clickable { onEdit() },&#10;        elevation = CardDefaults.cardElevation(2.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(subject.name, style = MaterialTheme.typography.titleMedium)&#10;                    Text(subject.type, style = MaterialTheme.typography.bodyMedium)&#10;                    Text(&quot;Threshold: ${subject.threshold}%&quot;, style = MaterialTheme.typography.bodySmall)&#10;                    Text(&quot;Attended: ${subject.attendedClasses} / Total: ${subject.totalClasses}&quot;, style = MaterialTheme.typography.bodySmall)&#10;&#10;                    val attended = subject.attendedClasses&#10;                    val total = subject.totalClasses&#10;                    val threshold = subject.threshold&#10;                    val attendancePercent = if (total &gt; 0) attended * 100 / total else 0&#10;                    val thresholdPercent = threshold&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Box(modifier = Modifier.fillMaxWidth().height(20.dp)) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .background(MaterialTheme.colorScheme.secondary.copy(alpha = 0.5f))&#10;                        )&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxHeight()&#10;                                .fillMaxWidth(fraction = thresholdPercent / 100f)&#10;                                .background(MaterialTheme.colorScheme.error.copy(alpha = 0.75f))&#10;                        )&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxHeight()&#10;                                .fillMaxWidth(fraction = attendancePercent / 100f)&#10;                                .background(MaterialTheme.colorScheme.primary)&#10;                        )&#10;                    }&#10;                }&#10;                var showDeleteDialog by remember { mutableStateOf(false) }&#10;                IconButton(onClick = { showDeleteDialog = true }) {&#10;                    Icon(Icons.Default.Delete, contentDescription = &quot;Delete&quot;)&#10;                }&#10;                if (showDeleteDialog) {&#10;                    AlertDialog(&#10;                        onDismissRequest = { showDeleteDialog = false },&#10;                        title = { Text(&quot;Delete Subject&quot;) },&#10;                        text = { Text(&quot;Are you sure you want to delete this subject? This action cannot be undone.&quot;) },&#10;                        confirmButton = {&#10;                            Button(onClick = {&#10;                                showDeleteDialog = false&#10;                                localCoroutineScope.launch {&#10;                                    viewModel.deleteSubject(subject)&#10;                                    onDeleteSuccess(&quot;Subject deleted&quot;)&#10;                                }&#10;                            }) { Text(&quot;Delete&quot;) }&#10;                        },&#10;                        dismissButton = {&#10;                            Button(onClick = { showDeleteDialog = false }) { Text(&quot;Cancel&quot;) }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Text(&quot;Attendance: ${&quot;%.1f&quot;.format(attendancePercentage)}%&quot;, style = MaterialTheme.typography.bodyMedium)&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Text(&quot;History:&quot;, style = MaterialTheme.typography.titleSmall)&#10;            if (attendanceHistory.isEmpty()) {&#10;                Text(&quot;No attendance records yet.&quot;, style = MaterialTheme.typography.bodySmall)&#10;            } else {&#10;                attendanceHistory.take(5).forEach { record -&gt;&#10;                    val statusText = if (record.note != null &amp;&amp; record.note.contains(&quot;Manual record updated&quot;)) &quot;Updated&quot; else record.status.name&#10;                    Text(&quot;${record.date}: $statusText&quot;, style = MaterialTheme.typography.bodySmall)&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Button(onClick = onEditAttendance) {&#10;                Text(&quot;Edit Attendance&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;fun buildCsv(subjects: List&lt;Subject&gt;): String {&#10;    val header = &quot;Subject,Type,Threshold,Attended,Total,Percentage\n&quot;&#10;    val rows = subjects.joinToString(&quot;\n&quot;) {&#10;        val percentage = if (it.totalClasses &gt; 0) (it.attendedClasses * 100.0 / it.totalClasses) else 0.0&#10;        &quot;${it.name},${it.type},${it.threshold},${it.attendedClasses},${it.totalClasses},${&quot;%.2f&quot;.format(percentage)}&quot;&#10;    }&#10;    return header + rows&#10;}&#10;&#10;fun buildExcel(subjects: List&lt;Subject&gt;): ByteArray {&#10;    val workbook = XSSFWorkbook()&#10;    val sheet = workbook.createSheet(&quot;Attendance&quot;)&#10;    val header = listOf(&quot;Subject&quot;, &quot;Type&quot;, &quot;Threshold&quot;, &quot;Attended&quot;, &quot;Total&quot;, &quot;Percentage&quot;)&#10;    val headerRow = sheet.createRow(0)&#10;    header.forEachIndexed { idx, title -&gt;&#10;        val cell = headerRow.createCell(idx, CellType.STRING)&#10;        cell.setCellValue(title)&#10;    }&#10;    subjects.forEachIndexed { rowIdx, subject -&gt;&#10;        val row = sheet.createRow(rowIdx + 1)&#10;        row.createCell(0, CellType.STRING).setCellValue(subject.name)&#10;        row.createCell(1, CellType.STRING).setCellValue(subject.type)&#10;        row.createCell(2, CellType.NUMERIC).setCellValue(subject.threshold.toDouble())&#10;        row.createCell(3, CellType.NUMERIC).setCellValue(subject.attendedClasses.toDouble())&#10;        row.createCell(4, CellType.NUMERIC).setCellValue(subject.totalClasses.toDouble())&#10;        val percentage = if (subject.totalClasses &gt; 0) (subject.attendedClasses * 100.0 / subject.totalClasses) else 0.0&#10;        row.createCell(5, CellType.NUMERIC).setCellValue(percentage)&#10;    }&#10;    val out = java.io.ByteArrayOutputStream()&#10;    workbook.write(out)&#10;    workbook.close()&#10;    return out.toByteArray()&#10;}&#10;&#10;fun buildPdf(subjects: List&lt;Subject&gt;): ByteArray {&#10;    val pdfDocument = PdfDocument()&#10;    val pageInfo = PdfDocument.PageInfo.Builder(595, 842, 1).create() // A4 size&#10;    val page = pdfDocument.startPage(pageInfo)&#10;    val canvas = page.canvas&#10;    val paint = Paint()&#10;    paint.textSize = 16f&#10;    var y = 40f&#10;    val header = &quot;Subject | Type | Threshold | Attended | Total | Percentage&quot;&#10;    canvas.drawText(header, 40f, y, paint)&#10;    y += 30f&#10;    paint.textSize = 14f&#10;    subjects.forEach {&#10;        val percentage = if (it.totalClasses &gt; 0) (it.attendedClasses * 100.0 / it.totalClasses) else 0.0&#10;        val line = &quot;${it.name} | ${it.type} | ${it.threshold} | ${it.attendedClasses} | ${it.totalClasses} | ${&quot;%.2f&quot;.format(percentage)}%&quot;&#10;        canvas.drawText(line, 40f, y, paint)&#10;        y += 24f&#10;        if (y &gt; 800f) {&#10;            pdfDocument.finishPage(page)&#10;            val nextPageInfo = PdfDocument.PageInfo.Builder(595, 842, pdfDocument.pageCount + 1).create()&#10;            val nextPage = pdfDocument.startPage(nextPageInfo)&#10;            canvas.setBitmap(nextPage.canvas.bitmap)&#10;            y = 40f&#10;        }&#10;    }&#10;    pdfDocument.finishPage(page)&#10;    val out = java.io.ByteArrayOutputStream()&#10;    pdfDocument.writeTo(out)&#10;    pdfDocument.close()&#10;    return out.toByteArray()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/ui/screens/TimetableScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/ui/screens/TimetableScreen.kt" />
              <option name="originalContent" value="package com.example.attendance_tracker.ui.screens&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.example.attendance_tracker.viewmodel.TimetableViewModel&#10;import com.example.attendance_tracker.data.TimetableEntry&#10;import com.example.attendance_tracker.data.SubjectRepository&#10;import com.example.attendance_tracker.viewmodel.CommonSlotViewModel&#10;import java.time.DayOfWeek&#10;import java.time.format.TextStyle&#10;import java.time.format.DateTimeFormatter&#10;import com.vanpra.composematerialdialogs.MaterialDialog&#10;import com.vanpra.composematerialdialogs.datetime.time.timepicker&#10;import com.vanpra.composematerialdialogs.rememberMaterialDialogState&#10;import java.time.LocalTime&#10;import java.util.Locale&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.foundation.background&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TimetableScreen(&#10;    timetableViewModel: TimetableViewModel,&#10;    subjectRepository: SubjectRepository,&#10;    commonSlotViewModel: CommonSlotViewModel = androidx.lifecycle.viewmodel.compose.viewModel()&#10;) {&#10;    val daysOfWeek = DayOfWeek.values().map { it.getDisplayName(TextStyle.FULL, Locale.US) }&#10;    var selectedDay by remember { mutableStateOf(daysOfWeek[0]) }&#10;    val timetableEntries by timetableViewModel.getEntriesForDay(selectedDay).collectAsState()&#10;    var showDialog by remember { mutableStateOf(false) }&#10;    var editingEntry by remember { mutableStateOf&lt;TimetableEntry?&gt;(null) }&#10;    var subject by remember { mutableStateOf(&quot;&quot;) } &#10;    val subjects by subjectRepository.allSubjects.collectAsState(initial = emptyList())&#10;    var startTime by remember { mutableStateOf(LocalTime.parse(&quot;09:00 AM&quot;, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))) }&#10;    var endTime by remember { mutableStateOf(LocalTime.parse(&quot;10:00 AM&quot;, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))) }&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val slotEntities by commonSlotViewModel.slots.collectAsState() &#10;&#10;    LaunchedEffect(errorMessage) {&#10;        errorMessage?.let {&#10;            snackbarHostState.showSnackbar(it)&#10;            errorMessage = null&#10;        }&#10;    }&#10;    &#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Timetable Editor&quot;) },&#10;                actions = {&#10;                    IconButton(onClick = {&#10;                        editingEntry = null&#10;                        subject = &quot;&quot;&#10;                        startTime = LocalTime.parse(&quot;09:00 AM&quot;, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                        endTime = LocalTime.parse(&quot;10:00 AM&quot;, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                        showDialog = true&#10;                    }) {&#10;                        Icon(Icons.Filled.Add, contentDescription = &quot;Add Timetable Entry&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Column(modifier = Modifier.fillMaxSize().padding(innerPadding)) {&#10;            Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.padding(8.dp)) {&#10;                Text(&quot;Select Day :&quot;, modifier = Modifier.padding(end = 8.dp))&#10;                DropdownMenuBox(daysOfWeek, selectedDay) { selectedDay = it }&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            if (timetableEntries.isEmpty()) {&#10;                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;                    Text(&quot;No timetable entries for $selectedDay.&quot;)&#10;                }&#10;            } else {&#10;                Column(modifier = Modifier.fillMaxSize()) {&#10;                    timetableEntries.forEach { entry -&gt;&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth().padding(8.dp),&#10;                            elevation = CardDefaults.cardElevation(2.dp)&#10;                        ) {&#10;                            Row(modifier = Modifier.padding(16.dp), verticalAlignment = Alignment.CenterVertically) {&#10;                                Column(modifier = Modifier.weight(1f)) {&#10;                                    Text(entry.subject, style = MaterialTheme.typography.titleMedium)&#10;                                    Text(&quot;${entry.startTime} - ${entry.endTime}&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                }&#10;                                IconButton(onClick = {&#10;                                    editingEntry = entry&#10;                                    subject = entry.subject&#10;                                    // Enhanced time parsing with fallback and added debugging logs&#10;                                    startTime = try {&#10;                                        val parsedTime = LocalTime.parse(entry.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                                        println(&quot;Parsed start time: $parsedTime&quot;) // Debugging log&#10;                                        parsedTime&#10;                                    } catch (e: Exception) {&#10;                                        println(&quot;Failed to parse start time: '${entry.startTime}' - ${e.message}&quot;) // Debugging log&#10;                                        LocalTime.of(9, 0) // Default to 09:00 AM&#10;                                    }&#10;                                    endTime = try {&#10;                                        val parsedTime = LocalTime.parse(entry.endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                                        println(&quot;Parsed end time: $parsedTime&quot;) // Debugging log&#10;                                        parsedTime&#10;                                    } catch (e: Exception) {&#10;                                        println(&quot;Failed to parse end time: '${entry.endTime}' - ${e.message}&quot;) // Debugging log&#10;                                        LocalTime.of(10, 0) // Default to 10:00 AM&#10;                                    }&#10;                                    showDialog = true&#10;                                }) {&#10;                                    Icon(Icons.Filled.Edit, contentDescription = &quot;Edit&quot;)&#10;                                }&#10;                                IconButton(onClick = {&#10;                                    coroutineScope.launch {&#10;                                        timetableViewModel.deleteEntry(entry)&#10;                                        errorMessage = &quot;Entry deleted&quot;&#10;                                    }&#10;                                }) {&#10;                                    Icon(Icons.Filled.Delete, contentDescription = &quot;Delete&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (showDialog) {&#10;                var subjectDropdownExpanded by remember { mutableStateOf(false) }&#10;                val subjectOptions = subjects.map { it.name }&#10;                var selectedSubject by remember { mutableStateOf(subjectOptions.firstOrNull() ?: &quot;&quot;) }&#10;                val selectedSlotIds = remember { mutableStateListOf&lt;Int&gt;() }&#10;                var slotSelectionError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;                var dialogErrorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;                AlertDialog(&#10;                    onDismissRequest = { showDialog = false },&#10;                    confirmButton = {&#10;                        Button(onClick = {&#10;                            if (selectedSubject.isBlank() || selectedSlotIds.isEmpty() || slotSelectionError != null) {&#10;                                dialogErrorMessage = slotSelectionError ?: &quot;Please select subject and valid slots.&quot;&#10;                                return@Button&#10;                            }&#10;                            // Build selectedSlots from slotEntities and selectedSlotIds&#10;                            val selectedSlots = slotEntities.filter { selectedSlotIds.contains(it.id) }&#10;                                .sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US)) }&#10;                            val newStart = LocalTime.parse(selectedSlots.first().startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                            val newEnd = LocalTime.parse(selectedSlots.last().endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                            val conflict = timetableEntries.any { entry -&gt;&#10;                                if (editingEntry != null &amp;&amp; entry.id == editingEntry!!.id) return@any false // skip self when editing&#10;                                val entryStart = LocalTime.parse(entry.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                                val entryEnd = LocalTime.parse(entry.endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                                // Overlapping time check&#10;                                val timeOverlap = newStart &lt; entryEnd &amp;&amp; newEnd &gt; entryStart&#10;                                // Duplicate slot check&#10;                                val slotOverlap = entry.slotIds.any { selectedSlotIds.contains(it) }&#10;                                timeOverlap || slotOverlap&#10;                            }&#10;                            if (conflict) {&#10;                                dialogErrorMessage = &quot;Conflict: Overlapping time or duplicate slot with another entry.&quot;&#10;                                return@Button&#10;                            }&#10;                            coroutineScope.launch {&#10;                                val selectedSlots = slotEntities.filter { selectedSlotIds.contains(it.id) }&#10;                                    .sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US)) }&#10;                                val startStr = selectedSlots.first().startTime&#10;                                val endStr = selectedSlots.last().endTime&#10;                                if (editingEntry == null) {&#10;                                    timetableViewModel.addEntry(&#10;                                        TimetableEntry(&#10;                                            dayOfWeek = selectedDay,&#10;                                            subject = selectedSubject,&#10;                                            startTime = startStr,&#10;                                            endTime = endStr,&#10;                                            slotIds = selectedSlotIds.toList()&#10;                                        )&#10;                                    )&#10;                                    errorMessage = &quot;Entry added&quot;&#10;                                } else {&#10;                                    timetableViewModel.deleteEntry(editingEntry!!)&#10;                                    timetableViewModel.addEntry(&#10;                                        TimetableEntry(&#10;                                            id = editingEntry!!.id,&#10;                                            dayOfWeek = selectedDay,&#10;                                            subject = selectedSubject,&#10;                                            startTime = startStr,&#10;                                            endTime = endStr,&#10;                                            slotIds = selectedSlotIds.toList()&#10;                                        )&#10;                                    )&#10;                                    errorMessage = &quot;Entry updated&quot;&#10;                                }&#10;                                showDialog = false&#10;                            }&#10;                        }) {&#10;                            Text(&quot;Save&quot;)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        OutlinedButton(onClick = { showDialog = false }) {&#10;                            Text(&quot;Cancel&quot;)&#10;                        }&#10;                    },&#10;                    title = { Text(if (editingEntry == null) &quot;Add Timetable Entry&quot; else &quot;Edit Timetable Entry&quot;) },&#10;                    text = {&#10;                        Column {&#10;                            Text(&quot;Select Subject:&quot;)&#10;                            ExposedDropdownMenuBox(&#10;                                expanded = subjectDropdownExpanded,&#10;                                onExpandedChange = { subjectDropdownExpanded = it }&#10;                            ) {&#10;                                OutlinedTextField(&#10;                                    value = selectedSubject,&#10;                                    onValueChange = {},&#10;                                    readOnly = true,&#10;                                    label = { Text(&quot;Subject&quot;) },&#10;                                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = subjectDropdownExpanded) },&#10;                                    modifier = Modifier.menuAnchor()&#10;                                )&#10;                                ExposedDropdownMenu(&#10;                                    expanded = subjectDropdownExpanded,&#10;                                    onDismissRequest = { subjectDropdownExpanded = false }&#10;                                ) {&#10;                                    subjectOptions.forEach { subj -&gt;&#10;                                        DropdownMenuItem(&#10;                                            text = { Text(subj) },&#10;                                            onClick = {&#10;                                                selectedSubject = subj&#10;                                                subjectDropdownExpanded = false&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&quot;Select Time Slots (≤20 min gap):&quot;)&#10;                            Box(modifier = Modifier.height(220.dp)) {&#10;                                LazyColumn {&#10;                                    items(slotEntities.sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US)) }) { slot -&gt;&#10;                                        val checked = selectedSlotIds.contains(slot.id)&#10;                                        Button(&#10;                                            onClick = {&#10;                                                if (!checked) {&#10;                                                    val allSelected = selectedSlotIds + slot.id&#10;                                                    val sortedSlots = slotEntities.filter { allSelected.contains(it.id) }&#10;                                                        .sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US)) }&#10;                                                    val valid = sortedSlots.zipWithNext().all { (a, b) -&gt;&#10;                                                        val aEnd = LocalTime.parse(a.endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                                                        val bStart = LocalTime.parse(b.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                                                        java.time.Duration.between(aEnd, bStart).toMinutes() &lt;= 20&#10;                                                    }&#10;                                                    if (valid) {&#10;                                                        selectedSlotIds.add(slot.id)&#10;                                                        slotSelectionError = null&#10;                                                    } else {&#10;                                                        slotSelectionError = &quot;Selected slots must be consecutive with ≤20 min gap.&quot;&#10;                                                    }&#10;                                                } else {&#10;                                                    selectedSlotIds.remove(slot.id)&#10;                                                    slotSelectionError = null&#10;                                                }&#10;                                            },&#10;                                            colors = ButtonDefaults.buttonColors(&#10;                                                containerColor = if (checked) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.surface,&#10;                                                contentColor = if (checked) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface&#10;                                            ),&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .padding(vertical = 4.dp)&#10;                                        ) {&#10;                                            Text(&quot;${slot.label}: ${slot.startTime} - ${slot.endTime}&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                            if (slotSelectionError != null) {&#10;                                Text(slotSelectionError!!, color = MaterialTheme.colorScheme.error)&#10;                            }&#10;                            if (!dialogErrorMessage.isNullOrBlank()) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(vertical = 8.dp)&#10;                                        .background(&#10;                                            color = MaterialTheme.colorScheme.error.copy(alpha = 0.1f),&#10;                                            shape = MaterialTheme.shapes.medium&#10;                                        )&#10;                                        .padding(12.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Error,&#10;                                        contentDescription = &quot;Error&quot;,&#10;                                        tint = MaterialTheme.colorScheme.error,&#10;                                        modifier = Modifier.size(24.dp)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(8.dp))&#10;                                    Text(&#10;                                        text = dialogErrorMessage!!,&#10;                                        color = MaterialTheme.colorScheme.error,&#10;                                        style = MaterialTheme.typography.bodyMedium,&#10;                                        modifier = Modifier.weight(1f)&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TimePickerDialogSample(&#10;    selectedTime: LocalTime,&#10;    onTimeSelected: (LocalTime) -&gt; Unit&#10;) {&#10;    val timeDialogState = rememberMaterialDialogState()&#10;    val time = remember { mutableStateOf(selectedTime) }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(48.dp)&#10;            .padding(vertical = 4.dp)&#10;            .clip(MaterialTheme.shapes.medium)&#10;            .background(MaterialTheme.colorScheme.surfaceVariant)&#10;            .clickable { timeDialogState.show() },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = time.value.format(java.time.format.DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US)),&#10;            textAlign = TextAlign.Center,&#10;            style = MaterialTheme.typography.bodyLarge,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;        )&#10;    }&#10;    MaterialDialog(&#10;        dialogState = timeDialogState,&#10;        buttons = {&#10;            positiveButton(&quot;OK&quot;)&#10;            negativeButton(&quot;Cancel&quot;)&#10;        }&#10;    ) {&#10;        timepicker(&#10;            initialTime = time.value,&#10;            title = &quot;Select Time&quot;&#10;        ) { newTime -&gt;&#10;            onTimeSelected(newTime)&#10;            time.value = newTime&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun DropdownMenuBox(options: List&lt;String&gt;, selected: String, onSelected: (String) -&gt; Unit) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;    Box {&#10;        Button(onClick = { expanded = true }) {&#10;            Text(selected)&#10;        }&#10;        DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {&#10;            options.forEach { option -&gt;&#10;                DropdownMenuItem(text = { Text(option) }, onClick = {&#10;                    onSelected(option)&#10;                    expanded = false&#10;                })&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.attendance_tracker.ui.screens&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Error&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.example.attendance_tracker.viewmodel.TimetableViewModel&#10;import com.example.attendance_tracker.data.TimetableEntry&#10;import com.example.attendance_tracker.data.SubjectRepository&#10;import com.example.attendance_tracker.viewmodel.CommonSlotViewModel&#10;import java.time.DayOfWeek&#10;import java.time.format.TextStyle&#10;import java.time.format.DateTimeFormatter&#10;import com.vanpra.composematerialdialogs.MaterialDialog&#10;import com.vanpra.composematerialdialogs.datetime.time.timepicker&#10;import com.vanpra.composematerialdialogs.rememberMaterialDialogState&#10;import java.time.LocalTime&#10;import java.util.Locale&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.foundation.background&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TimetableScreen(&#10;    timetableViewModel: TimetableViewModel,&#10;    subjectRepository: SubjectRepository,&#10;    commonSlotViewModel: CommonSlotViewModel = androidx.lifecycle.viewmodel.compose.viewModel()&#10;) {&#10;    val daysOfWeek = DayOfWeek.values().map { it.getDisplayName(TextStyle.FULL, Locale.US) }&#10;    var selectedDay by remember { mutableStateOf(daysOfWeek[0]) }&#10;    val timetableEntries by timetableViewModel.getEntriesForDay(selectedDay).collectAsState()&#10;    var showDialog by remember { mutableStateOf(false) }&#10;    var editingEntry by remember { mutableStateOf&lt;TimetableEntry?&gt;(null) }&#10;    var subject by remember { mutableStateOf(&quot;&quot;) } &#10;    val subjects by subjectRepository.allSubjects.collectAsState(initial = emptyList())&#10;    var startTime by remember { mutableStateOf(LocalTime.parse(&quot;09:00 AM&quot;, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))) }&#10;    var endTime by remember { mutableStateOf(LocalTime.parse(&quot;10:00 AM&quot;, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))) }&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val slotEntities by commonSlotViewModel.slots.collectAsState() &#10;&#10;    LaunchedEffect(errorMessage) {&#10;        errorMessage?.let {&#10;            snackbarHostState.showSnackbar(it)&#10;            errorMessage = null&#10;        }&#10;    }&#10;    &#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Timetable Editor&quot;) },&#10;                actions = {&#10;                    IconButton(onClick = {&#10;                        editingEntry = null&#10;                        subject = &quot;&quot;&#10;                        startTime = LocalTime.parse(&quot;09:00 AM&quot;, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                        endTime = LocalTime.parse(&quot;10:00 AM&quot;, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                        showDialog = true&#10;                    }) {&#10;                        Icon(Icons.Filled.Add, contentDescription = &quot;Add Timetable Entry&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Column(modifier = Modifier.fillMaxSize().padding(innerPadding)) {&#10;            Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.padding(8.dp)) {&#10;                Text(&quot;Select Day :&quot;, modifier = Modifier.padding(end = 8.dp))&#10;                DropdownMenuBox(daysOfWeek, selectedDay) { selectedDay = it }&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            if (timetableEntries.isEmpty()) {&#10;                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;                    Text(&quot;No timetable entries for $selectedDay.&quot;)&#10;                }&#10;            } else {&#10;                Column(modifier = Modifier.fillMaxSize()) {&#10;                    timetableEntries.forEach { entry -&gt;&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth().padding(8.dp),&#10;                            elevation = CardDefaults.cardElevation(2.dp)&#10;                        ) {&#10;                            Row(modifier = Modifier.padding(16.dp), verticalAlignment = Alignment.CenterVertically) {&#10;                                Column(modifier = Modifier.weight(1f)) {&#10;                                    Text(entry.subject, style = MaterialTheme.typography.titleMedium)&#10;                                    Text(&quot;${entry.startTime} - ${entry.endTime}&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                }&#10;                                IconButton(onClick = {&#10;                                    editingEntry = entry&#10;                                    subject = entry.subject&#10;                                    // Enhanced time parsing with fallback and added debugging logs&#10;                                    startTime = try {&#10;                                        val parsedTime = LocalTime.parse(entry.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                                        println(&quot;Parsed start time: $parsedTime&quot;) // Debugging log&#10;                                        parsedTime&#10;                                    } catch (e: Exception) {&#10;                                        println(&quot;Failed to parse start time: '${entry.startTime}' - ${e.message}&quot;) // Debugging log&#10;                                        LocalTime.of(9, 0) // Default to 09:00 AM&#10;                                    }&#10;                                    endTime = try {&#10;                                        val parsedTime = LocalTime.parse(entry.endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                                        println(&quot;Parsed end time: $parsedTime&quot;) // Debugging log&#10;                                        parsedTime&#10;                                    } catch (e: Exception) {&#10;                                        println(&quot;Failed to parse end time: '${entry.endTime}' - ${e.message}&quot;) // Debugging log&#10;                                        LocalTime.of(10, 0) // Default to 10:00 AM&#10;                                    }&#10;                                    showDialog = true&#10;                                }) {&#10;                                    Icon(Icons.Filled.Edit, contentDescription = &quot;Edit&quot;)&#10;                                }&#10;                                IconButton(onClick = {&#10;                                    coroutineScope.launch {&#10;                                        timetableViewModel.deleteEntry(entry)&#10;                                        errorMessage = &quot;Entry deleted&quot;&#10;                                    }&#10;                                }) {&#10;                                    Icon(Icons.Filled.Delete, contentDescription = &quot;Delete&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (showDialog) {&#10;                var subjectDropdownExpanded by remember { mutableStateOf(false) }&#10;                val subjectOptions = subjects.map { it.name }&#10;                var selectedSubject by remember { mutableStateOf(subjectOptions.firstOrNull() ?: &quot;&quot;) }&#10;                val selectedSlotIds = remember { mutableStateListOf&lt;Int&gt;() }&#10;                var slotSelectionError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;                var dialogErrorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;                AlertDialog(&#10;                    onDismissRequest = { showDialog = false },&#10;                    confirmButton = {&#10;                        Button(onClick = {&#10;                            if (selectedSubject.isBlank() || selectedSlotIds.isEmpty() || slotSelectionError != null) {&#10;                                dialogErrorMessage = slotSelectionError ?: &quot;Please select subject and valid slots.&quot;&#10;                                return@Button&#10;                            }&#10;                            // Build selectedSlots from slotEntities and selectedSlotIds&#10;                            val selectedSlots = slotEntities.filter { selectedSlotIds.contains(it.id) }&#10;                                .sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US)) }&#10;                            val newStart = LocalTime.parse(selectedSlots.first().startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                            val newEnd = LocalTime.parse(selectedSlots.last().endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                            val conflict = timetableEntries.any { entry -&gt;&#10;                                if (editingEntry != null &amp;&amp; entry.id == editingEntry!!.id) return@any false // skip self when editing&#10;                                val entryStart = LocalTime.parse(entry.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                                val entryEnd = LocalTime.parse(entry.endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                                // Overlapping time check&#10;                                val timeOverlap = newStart &lt; entryEnd &amp;&amp; newEnd &gt; entryStart&#10;                                // Duplicate slot check&#10;                                val slotOverlap = entry.slotIds.any { selectedSlotIds.contains(it) }&#10;                                timeOverlap || slotOverlap&#10;                            }&#10;                            if (conflict) {&#10;                                dialogErrorMessage = &quot;Conflict: Overlapping time or duplicate slot with another entry.&quot;&#10;                                return@Button&#10;                            }&#10;                            coroutineScope.launch {&#10;                                val selectedSlots = slotEntities.filter { selectedSlotIds.contains(it.id) }&#10;                                    .sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US)) }&#10;                                val startStr = selectedSlots.first().startTime&#10;                                val endStr = selectedSlots.last().endTime&#10;                                if (editingEntry == null) {&#10;                                    timetableViewModel.addEntry(&#10;                                        TimetableEntry(&#10;                                            dayOfWeek = selectedDay,&#10;                                            subject = selectedSubject,&#10;                                            startTime = startStr,&#10;                                            endTime = endStr,&#10;                                            slotIds = selectedSlotIds.toList()&#10;                                        )&#10;                                    )&#10;                                    errorMessage = &quot;Entry added&quot;&#10;                                } else {&#10;                                    timetableViewModel.deleteEntry(editingEntry!!)&#10;                                    timetableViewModel.addEntry(&#10;                                        TimetableEntry(&#10;                                            id = editingEntry!!.id,&#10;                                            dayOfWeek = selectedDay,&#10;                                            subject = selectedSubject,&#10;                                            startTime = startStr,&#10;                                            endTime = endStr,&#10;                                            slotIds = selectedSlotIds.toList()&#10;                                        )&#10;                                    )&#10;                                    errorMessage = &quot;Entry updated&quot;&#10;                                }&#10;                                showDialog = false&#10;                            }&#10;                        }) {&#10;                            Text(&quot;Save&quot;)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        OutlinedButton(onClick = { showDialog = false }) {&#10;                            Text(&quot;Cancel&quot;)&#10;                        }&#10;                    },&#10;                    title = { Text(if (editingEntry == null) &quot;Add Timetable Entry&quot; else &quot;Edit Timetable Entry&quot;) },&#10;                    text = {&#10;                        Column {&#10;                            Text(&quot;Select Subject:&quot;)&#10;                            ExposedDropdownMenuBox(&#10;                                expanded = subjectDropdownExpanded,&#10;                                onExpandedChange = { subjectDropdownExpanded = it }&#10;                            ) {&#10;                                OutlinedTextField(&#10;                                    value = selectedSubject,&#10;                                    onValueChange = {},&#10;                                    readOnly = true,&#10;                                    label = { Text(&quot;Subject&quot;) },&#10;                                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = subjectDropdownExpanded) },&#10;                                    modifier = Modifier.menuAnchor()&#10;                                )&#10;                                ExposedDropdownMenu(&#10;                                    expanded = subjectDropdownExpanded,&#10;                                    onDismissRequest = { subjectDropdownExpanded = false }&#10;                                ) {&#10;                                    subjectOptions.forEach { subj -&gt;&#10;                                        DropdownMenuItem(&#10;                                            text = { Text(subj) },&#10;                                            onClick = {&#10;                                                selectedSubject = subj&#10;                                                subjectDropdownExpanded = false&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&quot;Select Time Slots (≤20 min gap):&quot;)&#10;                            Box(modifier = Modifier.height(220.dp)) {&#10;                                LazyColumn {&#10;                                    items(slotEntities.sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US)) }) { slot -&gt;&#10;                                        val checked = selectedSlotIds.contains(slot.id)&#10;                                        Button(&#10;                                            onClick = {&#10;                                                if (!checked) {&#10;                                                    val allSelected = selectedSlotIds + slot.id&#10;                                                    val sortedSlots = slotEntities.filter { allSelected.contains(it.id) }&#10;                                                        .sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US)) }&#10;                                                    val valid = sortedSlots.zipWithNext().all { (a, b) -&gt;&#10;                                                        val aEnd = LocalTime.parse(a.endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                                                        val bStart = LocalTime.parse(b.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US))&#10;                                                        java.time.Duration.between(aEnd, bStart).toMinutes() &lt;= 20&#10;                                                    }&#10;                                                    if (valid) {&#10;                                                        selectedSlotIds.add(slot.id)&#10;                                                        slotSelectionError = null&#10;                                                    } else {&#10;                                                        slotSelectionError = &quot;Selected slots must be consecutive with ≤20 min gap.&quot;&#10;                                                    }&#10;                                                } else {&#10;                                                    selectedSlotIds.remove(slot.id)&#10;                                                    slotSelectionError = null&#10;                                                }&#10;                                            },&#10;                                            colors = ButtonDefaults.buttonColors(&#10;                                                containerColor = if (checked) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.surface,&#10;                                                contentColor = if (checked) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface&#10;                                            ),&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .padding(vertical = 4.dp)&#10;                                        ) {&#10;                                            Text(&quot;${slot.label}: ${slot.startTime} - ${slot.endTime}&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                            if (slotSelectionError != null) {&#10;                                Text(slotSelectionError!!, color = MaterialTheme.colorScheme.error)&#10;                            }&#10;                            if (!dialogErrorMessage.isNullOrBlank()) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(vertical = 8.dp)&#10;                                        .background(&#10;                                            color = MaterialTheme.colorScheme.error.copy(alpha = 0.1f),&#10;                                            shape = MaterialTheme.shapes.medium&#10;                                        )&#10;                                        .padding(12.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Error,&#10;                                        contentDescription = &quot;Error&quot;,&#10;                                        tint = MaterialTheme.colorScheme.error,&#10;                                        modifier = Modifier.size(24.dp)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(8.dp))&#10;                                    Text(&#10;                                        text = dialogErrorMessage!!,&#10;                                        color = MaterialTheme.colorScheme.error,&#10;                                        style = MaterialTheme.typography.bodyMedium,&#10;                                        modifier = Modifier.weight(1f)&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TimePickerDialogSample(&#10;    selectedTime: LocalTime,&#10;    onTimeSelected: (LocalTime) -&gt; Unit&#10;) {&#10;    val timeDialogState = rememberMaterialDialogState()&#10;    val time = remember { mutableStateOf(selectedTime) }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(48.dp)&#10;            .padding(vertical = 4.dp)&#10;            .clip(MaterialTheme.shapes.medium)&#10;            .background(MaterialTheme.colorScheme.surfaceVariant)&#10;            .clickable { timeDialogState.show() },&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = time.value.format(java.time.format.DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;, Locale.US)),&#10;            textAlign = TextAlign.Center,&#10;            style = MaterialTheme.typography.bodyLarge,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;        )&#10;    }&#10;    MaterialDialog(&#10;        dialogState = timeDialogState,&#10;        buttons = {&#10;            positiveButton(&quot;OK&quot;)&#10;            negativeButton(&quot;Cancel&quot;)&#10;        }&#10;    ) {&#10;        timepicker(&#10;            initialTime = time.value,&#10;            title = &quot;Select Time&quot;&#10;        ) { newTime -&gt;&#10;            onTimeSelected(newTime)&#10;            time.value = newTime&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun DropdownMenuBox(options: List&lt;String&gt;, selected: String, onSelected: (String) -&gt; Unit) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;    Box {&#10;        Button(onClick = { expanded = true }) {&#10;            Text(selected)&#10;        }&#10;        DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {&#10;            options.forEach { option -&gt;&#10;                DropdownMenuItem(text = { Text(option) }, onClick = {&#10;                    onSelected(option)&#10;                    expanded = false&#10;                })&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/viewmodel/AttendanceViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/attendance_tracker/viewmodel/AttendanceViewModel.kt" />
              <option name="originalContent" value="package com.example.attendance_tracker.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.attendance_tracker.data.Attendance&#10;import com.example.attendance_tracker.data.AttendanceStatus&#10;import com.example.attendance_tracker.repository.AttendanceRepository&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;class AttendanceViewModel(val repository: AttendanceRepository) : ViewModel() {&#10;    private val _attendanceHistory = MutableStateFlow&lt;List&lt;Attendance&gt;&gt;(emptyList())&#10;    val attendanceHistory: StateFlow&lt;List&lt;Attendance&gt;&gt; = _attendanceHistory&#10;&#10;    private val _attendancePercentage = MutableStateFlow(0.0)&#10;    val attendancePercentage: StateFlow&lt;Double&gt; = _attendancePercentage&#10;&#10;    fun loadAttendance(subjectId: Int) {&#10;        viewModelScope.launch {&#10;            _attendanceHistory.value = repository.getAttendanceHistory(subjectId)&#10;            _attendancePercentage.value = repository.getAttendancePercentage(subjectId)&#10;        }&#10;    }&#10;&#10;    fun markAttendance(subjectId: Int, selectedSlots: List&lt;Int&gt;, date: String, status: AttendanceStatus) {&#10;        viewModelScope.launch {&#10;            for (slotId in selectedSlots) {&#10;                repository.markAttendanceForSlot(subjectId, slotId, date, status)&#10;                // Update attended/total classes in Subject&#10;                val subject = repository.getSubjectById(subjectId)&#10;                if (subject != null) {&#10;                    val attended = subject.attendedClasses + if (status == AttendanceStatus.PRESENT) 1 else 0&#10;                    val total = subject.totalClasses + 1&#10;                    repository.updateSubjectAttendance(subjectId, attended, total)&#10;                }&#10;            }&#10;            loadAttendance(subjectId)&#10;        }&#10;    }&#10;&#10;    fun updateManualAttendance(subjectId: Int, attended: Int, total: Int, note: String? = null, date: String? = null) {&#10;        viewModelScope.launch {&#10;            repository.updateSubjectAttendance(subjectId, attended, total)&#10;            if (note != null &amp;&amp; date != null) {&#10;                repository.addManualHistory(subjectId, date, note)&#10;                // Remove all previous attendance records for this subject&#10;                repository.deleteAllAttendanceForSubject(subjectId)&#10;                // Add new attendance records based on manual values&#10;                val presentCount = attended&#10;                val absentCount = total - attended&#10;                val today = date&#10;                repeat(presentCount) {&#10;                    repository.markAttendanceForSlot(subjectId, -1, today, AttendanceStatus.PRESENT)&#10;                }&#10;                repeat(absentCount) {&#10;                    repository.markAttendanceForSlot(subjectId, -1, today, AttendanceStatus.ABSENT)&#10;                }&#10;            }&#10;            loadAttendance(subjectId)&#10;        }&#10;    }&#10;&#10;    suspend fun getAttendanceStatusForSubjectOnDate(subjectId: Int, date: String): AttendanceStatus? {&#10;        val attendance = repository.getAttendanceForDate(subjectId, date)&#10;        return attendance?.status&#10;    }&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.attendance_tracker.viewmodel&#13;&#10;&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.example.attendance_tracker.data.Attendance&#13;&#10;import com.example.attendance_tracker.data.AttendanceStatus&#13;&#10;import com.example.attendance_tracker.repository.AttendanceRepository&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;&#13;&#10;class AttendanceViewModel(val repository: AttendanceRepository) : ViewModel() {&#13;&#10;    private val _attendanceHistory = MutableStateFlow&lt;List&lt;Attendance&gt;&gt;(emptyList())&#13;&#10;    val attendanceHistory: StateFlow&lt;List&lt;Attendance&gt;&gt; = _attendanceHistory&#13;&#10;&#13;&#10;    private val _attendancePercentage = MutableStateFlow(0.0)&#13;&#10;    val attendancePercentage: StateFlow&lt;Double&gt; = _attendancePercentage&#13;&#10;&#13;&#10;    // Add StateFlow for attendance status per subject/date&#13;&#10;    private val _attendanceStatusMap = MutableStateFlow&lt;Map&lt;Pair&lt;Int, String&gt;, AttendanceStatus?&gt;&gt;(emptyMap())&#13;&#10;    fun getAttendanceStatusFlow(subjectId: Int?, date: String): StateFlow&lt;AttendanceStatus?&gt; {&#13;&#10;        val key = if (subjectId != null) Pair(subjectId, date) else null&#13;&#10;        return MutableStateFlow(_attendanceStatusMap.value[key] ?: null)&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun updateAttendanceStatusFlow(subjectId: Int, date: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val status = getAttendanceStatusForSubjectOnDate(subjectId, date)&#13;&#10;            val key = Pair(subjectId, date)&#13;&#10;            _attendanceStatusMap.value = _attendanceStatusMap.value.toMutableMap().apply {&#13;&#10;                put(key, status)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun loadAttendance(subjectId: Int) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _attendanceHistory.value = repository.getAttendanceHistory(subjectId)&#13;&#10;            _attendancePercentage.value = repository.getAttendancePercentage(subjectId)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun markAttendance(subjectId: Int, selectedSlots: List&lt;Int&gt;, date: String, status: AttendanceStatus) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            // Mark attendance for all slots, but only update attended/total once per subject per day&#13;&#10;            selectedSlots.forEach { slotId -&gt;&#13;&#10;                repository.markAttendanceForSlot(subjectId, slotId, date, status)&#13;&#10;            }&#13;&#10;            val subject = repository.getSubjectById(subjectId)&#13;&#10;            if (subject != null) {&#13;&#10;                val slotCount = selectedSlots.size&#13;&#10;                val attended = subject.attendedClasses + if (status == AttendanceStatus.PRESENT) slotCount else 0&#13;&#10;                val total = subject.totalClasses + slotCount&#13;&#10;                repository.updateSubjectAttendance(subjectId, attended, total)&#13;&#10;            }&#13;&#10;            loadAttendance(subjectId)&#13;&#10;            updateAttendanceStatusFlow(subjectId, date)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun updateManualAttendance(subjectId: Int, attended: Int, total: Int, note: String? = null, date: String? = null) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            repository.updateSubjectAttendance(subjectId, attended, total)&#13;&#10;            if (note != null &amp;&amp; date != null) {&#13;&#10;                repository.addManualHistory(subjectId, date, note)&#13;&#10;                // Remove all previous attendance records for this subject&#13;&#10;                repository.deleteAllAttendanceForSubject(subjectId)&#13;&#10;                // Add new attendance records based on manual values&#13;&#10;                val presentCount = attended&#13;&#10;                val absentCount = total - attended&#13;&#10;                val today = date&#13;&#10;                repeat(presentCount) {&#13;&#10;                    repository.markAttendanceForSlot(subjectId, -1, today, AttendanceStatus.PRESENT)&#13;&#10;                }&#13;&#10;                repeat(absentCount) {&#13;&#10;                    repository.markAttendanceForSlot(subjectId, -1, today, AttendanceStatus.ABSENT)&#13;&#10;                }&#13;&#10;            }&#13;&#10;            loadAttendance(subjectId)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun getAttendanceStatusForSubjectOnDate(subjectId: Int, date: String): AttendanceStatus? {&#13;&#10;        val attendance = repository.getAttendanceForDate(subjectId, date)&#13;&#10;        return attendance?.status&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun updateAttendanceStatusForSubjectOnDate(subjectId: Int, date: String, status: AttendanceStatus) {&#13;&#10;        repository.updateAttendanceStatusForSubjectOnDate(subjectId, date, status)&#13;&#10;        updateAttendanceStatusFlow(subjectId, date)&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun deleteAttendanceForSubjectOnDate(subjectId: Int, date: String) {&#13;&#10;        repository.deleteAttendanceForSubjectOnDate(subjectId, date)&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/lol/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/lol/MainActivity.kt" />
              <option name="originalContent" value="package com.example.lol&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import com.example.lol.ui.navigation.AppNavHost&#10;import com.example.lol.ui.navigation.BottomNavItem&#10;import com.example.lol.ui.theme.LOLTheme&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.School&#10;import androidx.compose.material.icons.filled.List&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.room.Room&#10;import com.example.lol.data.AppDatabase&#10;import com.example.lol.data.SubjectRepository&#10;import com.example.lol.repository.TimetableRepository&#10;import com.example.lol.viewmodel.TimetableViewModel&#10;import com.example.lol.viewmodel.TimetableViewModelFactory&#10;import androidx.compose.runtime.remember&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            LOLTheme {&#10;                val navController = rememberNavController()&#10;                val context = this&#10;                val db = remember {&#10;                    Room.databaseBuilder(&#10;                        context.applicationContext,&#10;                        AppDatabase::class.java,&#10;                        &quot;attendance_db&quot;&#10;                    )&#10;                    .fallbackToDestructiveMigration()&#10;                    .build()&#10;                }&#10;                val repository = remember { SubjectRepository(db.subjectDao()) }&#10;                val timetableRepository = remember { TimetableRepository(db.timetableDao()) }&#10;                val timetableViewModel: TimetableViewModel = androidx.lifecycle.viewmodel.compose.viewModel(&#10;                    factory = TimetableViewModelFactory(timetableRepository)&#10;                )&#10;                val items = listOf(&#10;                    BottomNavItem.Home,&#10;                    BottomNavItem.Subjects,&#10;                    BottomNavItem.Timetable,&#10;                    BottomNavItem.CommonSlots&#10;                )&#10;                val commonSlotViewModel: com.example.lol.viewmodel.CommonSlotViewModel = androidx.lifecycle.viewmodel.compose.viewModel()&#10;                // Always call insertDefaultSlotsIfEmpty; it only inserts if table is empty&#10;                commonSlotViewModel.insertDefaultSlotsIfEmpty()&#10;                val attendanceRepository = remember { com.example.lol.repository.AttendanceRepository(db.attendanceDao(), db.subjectDao()) }&#10;                val attendanceViewModel = remember { com.example.lol.viewmodel.AttendanceViewModel(attendanceRepository) }&#10;                Scaffold(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    bottomBar = {&#10;                        NavigationBar {&#10;                            val currentRoute = navController.currentBackStackEntry?.destination?.route&#10;                            items.forEach { item -&gt;&#10;                                NavigationBarItem(&#10;                                    icon = { Icon(item.icon, contentDescription = item.label) },&#10;                                    label = { Text(item.label) },&#10;                                    selected = currentRoute == item.route,&#10;                                    onClick = {&#10;                                        if (currentRoute != item.route) {&#10;                                            navController.navigate(item.route) {&#10;                                                popUpTo(navController.graph.startDestinationId) { saveState = true }&#10;                                                launchSingleTop = true&#10;                                                restoreState = true&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                ) { innerPadding -&gt;&#10;                    AppNavHost(&#10;                        navController = navController,&#10;                        repository = repository,&#10;                        timetableViewModel = timetableViewModel,&#10;                        commonSlotViewModel = commonSlotViewModel,&#10;                        attendanceViewModel = attendanceViewModel,&#10;                        modifier = Modifier.padding(innerPadding)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.lol&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import com.example.lol.ui.navigation.AppNavHost&#10;import com.example.lol.ui.navigation.BottomNavItem&#10;import com.example.lol.ui.theme.LOLTheme&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.School&#10;import androidx.compose.material.icons.filled.List&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.room.Room&#10;import com.example.lol.data.AppDatabase&#10;import com.example.lol.data.SubjectRepository&#10;import com.example.lol.repository.TimetableRepository&#10;import com.example.lol.viewmodel.TimetableViewModel&#10;import com.example.lol.viewmodel.TimetableViewModelFactory&#10;import androidx.compose.runtime.remember&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            LOLTheme {&#10;                val navController = rememberNavController()&#10;                val context = this&#10;                val db = remember {&#10;                    Room.databaseBuilder(&#10;                        context.applicationContext,&#10;                        AppDatabase::class.java,&#10;                        &quot;attendance_db&quot;&#10;                    )&#10;                    .fallbackToDestructiveMigration()&#10;                    .build()&#10;                }&#10;                val repository = remember { SubjectRepository(db.subjectDao()) }&#10;                val timetableRepository = remember { TimetableRepository(db.timetableDao()) }&#10;                val timetableViewModel: TimetableViewModel = androidx.lifecycle.viewmodel.compose.viewModel(&#10;                    factory = TimetableViewModelFactory(timetableRepository)&#10;                )&#10;                val items = listOf(&#10;                    BottomNavItem.Home,&#10;                    BottomNavItem.Subjects,&#10;                    BottomNavItem.Timetable,&#10;                    BottomNavItem.CommonSlots&#10;                )&#10;                val commonSlotViewModel: com.example.lol.viewmodel.CommonSlotViewModel = androidx.lifecycle.viewmodel.compose.viewModel()&#10;                // Always call insertDefaultSlotsIfEmpty; it only inserts if table is empty&#10;                commonSlotViewModel.insertDefaultSlotsIfEmpty()&#10;                val attendanceRepository = remember { com.example.lol.repository.AttendanceRepository(db.attendanceDao(), db.subjectDao(), repository) }&#10;                val attendanceViewModel = remember { com.example.lol.viewmodel.AttendanceViewModel(attendanceRepository) }&#10;                Scaffold(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    bottomBar = {&#10;                        NavigationBar {&#10;                            val currentRoute = navController.currentBackStackEntry?.destination?.route&#10;                            items.forEach { item -&gt;&#10;                                NavigationBarItem(&#10;                                    icon = { Icon(item.icon, contentDescription = item.label) },&#10;                                    label = { Text(item.label) },&#10;                                    selected = currentRoute == item.route,&#10;                                    onClick = {&#10;                                        if (currentRoute != item.route) {&#10;                                            navController.navigate(item.route) {&#10;                                                popUpTo(navController.graph.startDestinationId) { saveState = true }&#10;                                                launchSingleTop = true&#10;                                                restoreState = true&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                ) { innerPadding -&gt;&#10;                    AppNavHost(&#10;                        navController = navController,&#10;                        repository = repository,&#10;                        timetableViewModel = timetableViewModel,&#10;                        commonSlotViewModel = commonSlotViewModel,&#10;                        attendanceViewModel = attendanceViewModel,&#10;                        modifier = Modifier.padding(innerPadding)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/lol/repository/AttendanceRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/lol/repository/AttendanceRepository.kt" />
              <option name="originalContent" value="package com.example.lol.repository&#10;import com.example.lol.data.Attendance&#10;import com.example.lol.data.AttendanceDao&#10;import com.example.lol.data.AttendanceStatus&#10;import com.example.lol.data.SubjectRepository&#10;import com.example.lol.data.SubjectDao&#10;import com.example.lol.data.Subject&#10;&#10;class AttendanceRepository(private val attendanceDao: AttendanceDao, private val subjectDao: SubjectDao) {&#10;    suspend fun markAttendanceForSlot(subjectId: Int, slotId: Int, date: String, status: AttendanceStatus) {&#10;        val attendance = Attendance(subjectId = subjectId, slotId = slotId, date = date, status = status)&#10;        attendanceDao.insertAttendance(attendance)&#10;    }&#10;&#10;    suspend fun deleteAllAttendanceForSubject(subjectId: Int) {&#10;        attendanceDao.deleteAllForSubject(subjectId)&#10;    }&#10;&#10;    suspend fun getSubjectById(subjectId: Int): Subject? {&#10;        return subjectDao.getSubjectById(subjectId)&#10;    }&#10;    &#10;    suspend fun addManualHistory(subjectId: Int, date: String, note: String) {&#10;        val manual = Attendance(subjectId = subjectId, slotId = -1, date = date, status = AttendanceStatus.PRESENT, note = note)&#10;        attendanceDao.insertManualHistory(manual)&#10;    }&#10;&#10;    suspend fun updateSubjectAttendance(subjectId: Int, attended: Int, total: Int) {&#10;        val subject = subjectDao.getSubjectById(subjectId)&#10;        if (subject != null) {&#10;            val updated = subject.copy(attendedClasses = attended, totalClasses = total)&#10;            subjectDao.updateSubject(updated)&#10;            // Notify SubjectRepository to refresh subjects&#10;            SubjectRepository(subjectDao).refreshSubjects()&#10;        }&#10;    }&#10;&#10;    suspend fun getAttendanceHistory(subjectId: Int) = attendanceDao.getAttendanceForSubject(subjectId)&#10;&#10;    suspend fun getAttendanceForDate(subjectId: Int, date: String) = attendanceDao.getAttendanceForSubjectOnDate(subjectId, date)&#10;&#10;    suspend fun getAttendancePercentage(subjectId: Int): Double {&#10;        val total = attendanceDao.getTotalMarked(subjectId)&#10;        if (total == 0) return 0.0&#10;        val present = attendanceDao.getCountByStatus(subjectId, AttendanceStatus.PRESENT)&#10;        return (present.toDouble() / total) * 100&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.lol.repository&#10;import com.example.lol.data.Attendance&#10;import com.example.lol.data.AttendanceDao&#10;import com.example.lol.data.AttendanceStatus&#10;import com.example.lol.data.SubjectRepository&#10;import com.example.lol.data.SubjectDao&#10;import com.example.lol.data.Subject&#10;&#10;class AttendanceRepository(&#10;    private val attendanceDao: AttendanceDao,&#10;    private val subjectDao: SubjectDao,&#10;    private val subjectRepository: SubjectRepository // Injected shared instance&#10;) {&#10;    suspend fun markAttendanceForSlot(subjectId: Int, slotId: Int, date: String, status: AttendanceStatus) {&#10;        val attendance = Attendance(subjectId = subjectId, slotId = slotId, date = date, status = status)&#10;        attendanceDao.insertAttendance(attendance)&#10;    }&#10;&#10;    suspend fun deleteAllAttendanceForSubject(subjectId: Int) {&#10;        attendanceDao.deleteAllForSubject(subjectId)&#10;    }&#10;&#10;    suspend fun getSubjectById(subjectId: Int): Subject? {&#10;        return subjectDao.getSubjectById(subjectId)&#10;    }&#10;    &#10;    suspend fun addManualHistory(subjectId: Int, date: String, note: String) {&#10;        val manual = Attendance(subjectId = subjectId, slotId = -1, date = date, status = AttendanceStatus.PRESENT, note = note)&#10;        attendanceDao.insertManualHistory(manual)&#10;    }&#10;&#10;    suspend fun updateSubjectAttendance(subjectId: Int, attended: Int, total: Int) {&#10;        val subject = subjectDao.getSubjectById(subjectId)&#10;        if (subject != null) {&#10;            val updated = subject.copy(attendedClasses = attended, totalClasses = total)&#10;            subjectDao.updateSubject(updated)&#10;            // Notify shared SubjectRepository to refresh subjects&#10;            subjectRepository.refreshSubjects()&#10;        }&#10;    }&#10;&#10;    suspend fun getAttendanceHistory(subjectId: Int) = attendanceDao.getAttendanceForSubject(subjectId)&#10;&#10;    suspend fun getAttendanceForDate(subjectId: Int, date: String) = attendanceDao.getAttendanceForSubjectOnDate(subjectId, date)&#10;&#10;    suspend fun getAttendancePercentage(subjectId: Int): Double {&#10;        val total = attendanceDao.getTotalMarked(subjectId)&#10;        if (total == 0) return 0.0&#10;        val present = attendanceDao.getCountByStatus(subjectId, AttendanceStatus.PRESENT)&#10;        return (present.toDouble() / total) * 100&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>