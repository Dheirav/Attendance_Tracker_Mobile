<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/lol/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/lol/ui/screens/HomeScreen.kt" />
              <option name="originalContent" value="package com.example.lol.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.foundation.background&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import com.example.lol.viewmodel.TimetableViewModel&#10;import com.example.lol.data.TimetableEntry&#10;import com.example.lol.data.SubjectRepository&#10;import com.example.lol.viewmodel.CommonSlotViewModel&#10;import com.example.lol.viewmodel.AttendanceViewModel&#10;import com.example.lol.data.AttendanceStatus&#10;import java.time.LocalDate&#10;import java.time.format.TextStyle&#10;import java.util.Locale&#10;import java.time.LocalTime&#10;import java.time.format.DateTimeFormatter&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.material.DismissDirection&#10;import androidx.compose.material.DismissValue&#10;import androidx.compose.material.SwipeToDismiss&#10;import androidx.compose.material.rememberDismissState&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun HomeScreen(&#10;    timetableViewModel: TimetableViewModel,&#10;    subjectRepository: SubjectRepository,&#10;    commonSlotViewModel: CommonSlotViewModel = androidx.lifecycle.viewmodel.compose.viewModel(),&#10;    attendanceViewModel: AttendanceViewModel &#10;) {&#10;    val today = LocalDate.now().dayOfWeek.getDisplayName(TextStyle.FULL, Locale.getDefault())&#10;    val timetableEntries by timetableViewModel.getEntriesForDay(today).collectAsState()&#10;    var showDialog by remember { mutableStateOf(false) }&#10;    var editingEntry by remember { mutableStateOf&lt;TimetableEntry?&gt;(null) }&#10;    var subject by remember { mutableStateOf(&quot;&quot;) }&#10;    val subjects by subjectRepository.allSubjects.collectAsState(initial = emptyList())&#10;    val slotEntities by commonSlotViewModel.slots.collectAsState()&#10;    var selectedSlotLabel by remember { mutableStateOf(&quot;&quot;) }&#10;    var startTime by remember { mutableStateOf(&quot;&quot;) }&#10;    var endTime by remember { mutableStateOf(&quot;&quot;) }&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val todayDate = LocalDate.now()&#10;    val dayOfWeek = todayDate.dayOfWeek.getDisplayName(TextStyle.FULL, Locale.getDefault())&#10;    val dateStr = todayDate.format(java.time.format.DateTimeFormatter.ofPattern(&quot;dd MMMM yyyy&quot;))&#10;&#10;    LaunchedEffect(errorMessage) {&#10;        errorMessage?.let {&#10;            snackbarHostState.showSnackbar(it)&#10;            errorMessage = null&#10;        }&#10;    }&#10;&#10;   Scaffold(&#10;    topBar = {&#10;        TopAppBar(&#10;            title = { Text(&quot;Today - $dayOfWeek's Timetable&quot;) },&#10;            actions = {&#10;                IconButton(onClick = {&#10;                    editingEntry = null&#10;                    subject = &quot;&quot;&#10;                    startTime = &quot;&quot;&#10;                    endTime = &quot;&quot;&#10;                    selectedSlotLabel = &quot;&quot;&#10;                    showDialog = true&#10;                }) {&#10;                    Icon(Icons.Filled.Add, contentDescription = &quot;Add Timetable Entry&quot;)&#10;                }&#10;            }&#10;        )&#10;    },&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Box(modifier = Modifier.fillMaxSize().padding(innerPadding)) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(text = dateStr, style = MaterialTheme.typography.titleMedium)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;            }&#10;            if (timetableEntries.isEmpty()) {&#10;                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;                    Text(&quot;No timetable entries for today.&quot;)&#10;                }&#10;            } else {&#10;                Column(modifier = Modifier.fillMaxSize()) {&#10;                    timetableEntries.forEach { entry -&gt;&#10;                        // Find the slot(s) for this entry&#10;                        val entrySlots = slotEntities.filter {&#10;                            LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)) &gt;= LocalTime.parse(entry.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)) &amp;&amp;&#10;                            LocalTime.parse(it.endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)) &lt;= LocalTime.parse(entry.endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;))&#10;                        }&#10;                        val selectedSlots: List&lt;Int&gt; = entrySlots.map { it.id }&#10;                        val dismissState = rememberDismissState(&#10;                            confirmValueChange = { value -&gt;&#10;                                val subjectId = subjects.find { it.name == entry.subject }?.id ?: 0&#10;                                coroutineScope.launch {&#10;                                    if (value == DismissValue.DismissedToEnd) {&#10;                                        attendanceViewModel.markAttendance(&#10;                                            subjectId = subjectId,&#10;                                            selectedSlots = selectedSlots,&#10;                                            date = todayDate.toString(),&#10;                                            status = AttendanceStatus.PRESENT&#10;                                        )&#10;                                        errorMessage = &quot;Marked Present for ${entry.subject}&quot;&#10;                                    } else if (value == DismissValue.DismissedToStart) {&#10;                                        attendanceViewModel.markAttendance(&#10;                                            subjectId = subjectId,&#10;                                            selectedSlots = selectedSlots,&#10;                                            date = todayDate.toString(),&#10;                                            status = AttendanceStatus.ABSENT&#10;                                        )&#10;                                        errorMessage = &quot;Marked Absent for ${entry.subject}&quot;&#10;                                    }&#10;                                }&#10;                                false // Don't auto-remove card&#10;                            }&#10;                        )&#10;                        &#10;                        SwipeToDismiss(&#10;                            state = dismissState,&#10;                            directions = setOf(DismissDirection.StartToEnd, DismissDirection.EndToStart),&#10;                            background = {&#10;                                val direction = dismissState.dismissDirection&#10;                                val color = when (direction) {&#10;                                    DismissDirection.StartToEnd -&gt; MaterialTheme.colorScheme.primary&#10;                                    DismissDirection.EndToStart -&gt; MaterialTheme.colorScheme.error&#10;                                    else -&gt; MaterialTheme.colorScheme.surfaceVariant&#10;                                }&#10;                                Box(&#10;                                    Modifier&#10;                                        .fillMaxSize()&#10;                                        .background(color)&#10;                                )&#10;                            },&#10;                            dismissContent = {&#10;                                Card(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(8.dp),&#10;                                    elevation = CardDefaults.cardElevation(2.dp)&#10;                                ) {&#10;                                    Column(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .padding(16.dp)&#10;                                    ) {&#10;                                        Text(entry.subject, style = MaterialTheme.typography.titleMedium)&#10;                                        Text(&quot;${entry.startTime} - ${entry.endTime}&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                        // --- Attendance Progress Bar ---&#10;                                        val subjectObj = subjects.find { it.name == entry.subject }&#10;                                        val attended = subjectObj?.attendedClasses ?: 0&#10;                                        val total = subjectObj?.totalClasses ?: 0&#10;                                        val threshold = subjectObj?.threshold ?: 75&#10;                                        val attendancePercent = if (total &gt; 0) attended * 100 / total else 0&#10;                                        val thresholdPercent = threshold &#10;                                        Spacer(modifier = Modifier.height(8.dp))&#10;                                        Box(modifier = Modifier.fillMaxWidth().height(20.dp)) {&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxSize()&#10;                                                    .background(MaterialTheme.colorScheme.secondary.copy(alpha = 0.5f))&#10;                                            )&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxHeight()&#10;                                                    .fillMaxWidth(fraction = thresholdPercent / 100f)&#10;                                                    .background(MaterialTheme.colorScheme.error.copy(alpha = 0.75f))&#10;                                            )&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxHeight()&#10;                                                    .fillMaxWidth(fraction = attendancePercent / 100f)&#10;                                                    .background(MaterialTheme.colorScheme.primary)&#10;                                            )&#10;                                        }&#10;                                        Spacer(modifier = Modifier.height(2.dp))&#10;                                        Row(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.SpaceBetween&#10;                                        ) {&#10;                                            Text(&quot;Attendance: $attendancePercent%&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                            Text(&quot;Threshold: $thresholdPercent%&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                        }&#10;                                        // --- Edit/Delete Controls ---&#10;                                        Row(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.End&#10;                                        ) {&#10;                                            IconButton(onClick = {&#10;                                                editingEntry = entry&#10;                                                subject = entry.subject&#10;                                                startTime = entry.startTime&#10;                                                endTime = entry.endTime&#10;                                                showDialog = true&#10;                                            }) {&#10;                                                Icon(Icons.Filled.Edit, contentDescription = &quot;Edit&quot;)&#10;                                            }&#10;                                            IconButton(onClick = {&#10;                                                coroutineScope.launch {&#10;                                                    timetableViewModel.deleteEntry(entry)&#10;                                                    errorMessage = &quot;Entry deleted&quot;&#10;                                                }&#10;                                            }) {&#10;                                                Icon(Icons.Filled.Delete, contentDescription = &quot;Delete&quot;)&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (showDialog) {&#10;                var subjectDropdownExpanded by remember { mutableStateOf(false) }&#10;                val subjectOptions = subjects.map { it.name }&#10;                var selectedSubject by remember { mutableStateOf(subjectOptions.firstOrNull() ?: &quot;&quot;) }&#10;                val selectedSlotIds = remember { mutableStateListOf&lt;Int&gt;() }&#10;                var slotSelectionError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;            &#10;                AlertDialog(&#10;                    onDismissRequest = { showDialog = false },&#10;                    confirmButton = {&#10;                        Button(onClick = {&#10;                            if (selectedSubject.isBlank() || selectedSlotIds.isEmpty() || slotSelectionError != null) {&#10;                                errorMessage = slotSelectionError ?: &quot;Please select subject and valid slots.&quot;&#10;                                return@Button&#10;                            }&#10;                            coroutineScope.launch {&#10;                                val selectedSlots = slotEntities.filter { selectedSlotIds.contains(it.id) }&#10;                                    .sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)) }&#10;                                val startStr = selectedSlots.first().startTime&#10;                                val endStr = selectedSlots.last().endTime&#10;                                if (editingEntry == null) {&#10;                                    timetableViewModel.addEntry(&#10;                                        TimetableEntry(&#10;                                            dayOfWeek = today ,&#10;                                            subject = selectedSubject,&#10;                                            startTime = startStr,&#10;                                            endTime = endStr,&#10;                                            slotIds = selectedSlotIds.toList()&#10;                                        )&#10;                                    )&#10;                                    errorMessage = &quot;Entry added&quot;&#10;                                } else {&#10;                                    timetableViewModel.deleteEntry(editingEntry!!)&#10;                                    timetableViewModel.addEntry(&#10;                                        TimetableEntry(&#10;                                            id = editingEntry!!.id,&#10;                                            dayOfWeek = today ,&#10;                                            subject = selectedSubject,&#10;                                            startTime = startStr,&#10;                                            endTime = endStr,&#10;                                            slotIds = selectedSlotIds.toList()&#10;                                        )&#10;                                    )&#10;                                    errorMessage = &quot;Entry updated&quot;&#10;                                }&#10;                                showDialog = false&#10;                            }&#10;                        }) {&#10;                            Text(&quot;Save&quot;)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        OutlinedButton(onClick = { showDialog = false }) {&#10;                            Text(&quot;Cancel&quot;)&#10;                        }&#10;                    },&#10;                    title = { Text(if (editingEntry == null) &quot;Add Timetable Entry&quot; else &quot;Edit Timetable Entry&quot;) },&#10;                    text = {&#10;                        Column {&#10;                            Text(&quot;Select Subject:&quot;)&#10;                            ExposedDropdownMenuBox(&#10;                                expanded = subjectDropdownExpanded,&#10;                                onExpandedChange = { subjectDropdownExpanded = it }&#10;                            ) {&#10;                                OutlinedTextField(&#10;                                    value = selectedSubject,&#10;                                    onValueChange = {},&#10;                                    readOnly = true,&#10;                                    label = { Text(&quot;Subject&quot;) },&#10;                                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = subjectDropdownExpanded) },&#10;                                    modifier = Modifier.menuAnchor()&#10;                                )&#10;                                ExposedDropdownMenu(&#10;                                    expanded = subjectDropdownExpanded,&#10;                                    onDismissRequest = { subjectDropdownExpanded = false }&#10;                                ) {&#10;                                    subjectOptions.forEach { subj -&gt;&#10;                                        DropdownMenuItem(&#10;                                            text = { Text(subj) },&#10;                                            onClick = {&#10;                                                selectedSubject = subj&#10;                                                subjectDropdownExpanded = false&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&quot;Select Time Slots (≤20 min gap):&quot;)&#10;                            Box(modifier = Modifier.height(220.dp)) {&#10;                                LazyColumn {&#10;                                    items(slotEntities.sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)) }) { slot -&gt;&#10;                                        val checked = selectedSlotIds.contains(slot.id)&#10;                                        Button(&#10;                                            onClick = {&#10;                                                if (!checked) {&#10;                                                    val allSelected = selectedSlotIds + slot.id&#10;                                                    val sortedSlots = slotEntities.filter { allSelected.contains(it.id) }&#10;                                                        .sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)) }&#10;                                                    val valid = sortedSlots.zipWithNext().all { (a, b) -&gt;&#10;                                                        val aEnd = LocalTime.parse(a.endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;))&#10;                                                        val bStart = LocalTime.parse(b.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;))&#10;                                                        java.time.Duration.between(aEnd, bStart).toMinutes() &lt;= 20&#10;                                                    }&#10;                                                    if (valid) {&#10;                                                        selectedSlotIds.add(slot.id)&#10;                                                        slotSelectionError = null&#10;                                                    } else {&#10;                                                        slotSelectionError = &quot;Selected slots must be consecutive with ≤20 min gap.&quot;&#10;                                                    }&#10;                                                } else {&#10;                                                    selectedSlotIds.remove(slot.id)&#10;                                                    slotSelectionError = null&#10;                                                }&#10;                                            },&#10;                                            colors = ButtonDefaults.buttonColors(&#10;                                                containerColor = if (checked) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.surface,&#10;                                                contentColor = if (checked) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface&#10;                                            ),&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .padding(vertical = 4.dp)&#10;                                        ) {&#10;                                            Text(&quot;${slot.label}: ${slot.startTime} - ${slot.endTime}&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                            if (slotSelectionError != null) {&#10;                                Text(slotSelectionError!!, color = MaterialTheme.colorScheme.error)&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.lol.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.foundation.background&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.launch&#10;import com.example.lol.viewmodel.TimetableViewModel&#10;import com.example.lol.data.TimetableEntry&#10;import com.example.lol.data.SubjectRepository&#10;import com.example.lol.viewmodel.CommonSlotViewModel&#10;import com.example.lol.viewmodel.AttendanceViewModel&#10;import com.example.lol.data.AttendanceStatus&#10;import java.time.LocalDate&#10;import java.time.format.TextStyle&#10;import java.util.Locale&#10;import java.time.LocalTime&#10;import java.time.format.DateTimeFormatter&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.layout.Arrangement&#10;import com.example.lol.ui.components.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun HomeScreen(&#10;    timetableViewModel: TimetableViewModel,&#10;    subjectRepository: SubjectRepository,&#10;    commonSlotViewModel: CommonSlotViewModel = androidx.lifecycle.viewmodel.compose.viewModel(),&#10;    attendanceViewModel: AttendanceViewModel &#10;) {&#10;    val today = LocalDate.now().dayOfWeek.getDisplayName(TextStyle.FULL, Locale.getDefault())&#10;    val timetableEntries by timetableViewModel.getEntriesForDay(today).collectAsState()&#10;    var showDialog by remember { mutableStateOf(false) }&#10;    var editingEntry by remember { mutableStateOf&lt;TimetableEntry?&gt;(null) }&#10;    var subject by remember { mutableStateOf(&quot;&quot;) }&#10;    val subjects by subjectRepository.allSubjects.collectAsState(initial = emptyList())&#10;    val slotEntities by commonSlotViewModel.slots.collectAsState()&#10;    var selectedSlotLabel by remember { mutableStateOf(&quot;&quot;) }&#10;    var startTime by remember { mutableStateOf(&quot;&quot;) }&#10;    var endTime by remember { mutableStateOf(&quot;&quot;) }&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val todayDate = LocalDate.now()&#10;    val dayOfWeek = todayDate.dayOfWeek.getDisplayName(TextStyle.FULL, Locale.getDefault())&#10;    val dateStr = todayDate.format(java.time.format.DateTimeFormatter.ofPattern(&quot;dd MMMM yyyy&quot;))&#10;&#10;    LaunchedEffect(errorMessage) {&#10;        errorMessage?.let {&#10;            snackbarHostState.showSnackbar(it)&#10;            errorMessage = null&#10;        }&#10;    }&#10;&#10;   Scaffold(&#10;    topBar = {&#10;        TopAppBar(&#10;            title = { Text(&quot;Today - $dayOfWeek's Timetable&quot;) },&#10;            actions = {&#10;                IconButton(onClick = {&#10;                    editingEntry = null&#10;                    subject = &quot;&quot;&#10;                    startTime = &quot;&quot;&#10;                    endTime = &quot;&quot;&#10;                    selectedSlotLabel = &quot;&quot;&#10;                    showDialog = true&#10;                }) {&#10;                    Icon(Icons.Filled.Add, contentDescription = &quot;Add Timetable Entry&quot;)&#10;                }&#10;            }&#10;        )&#10;    },&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }&#10;    ) { innerPadding -&gt;&#10;        Box(modifier = Modifier.fillMaxSize().padding(innerPadding)) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(text = dateStr, style = MaterialTheme.typography.titleMedium)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;            }&#10;            if (timetableEntries.isEmpty()) {&#10;                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;                    Text(&quot;No timetable entries for today.&quot;)&#10;                }&#10;            } else {&#10;                Column(modifier = Modifier.fillMaxSize()) {&#10;                    timetableEntries.forEach { entry -&gt;&#10;                        // Find the slot(s) for this entry&#10;                        val entrySlots = slotEntities.filter {&#10;                            LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)) &gt;= LocalTime.parse(entry.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)) &amp;&amp;&#10;                            LocalTime.parse(it.endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)) &lt;= LocalTime.parse(entry.endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;))&#10;                        }&#10;                        val selectedSlots: List&lt;Int&gt; = entrySlots.map { it.id }&#10;                        val dismissState = rememberCustomDismissState()&#10;                        if (dismissState.value == CustomDismissValue.DismissedToEnd || dismissState.value == CustomDismissValue.DismissedToStart) {&#10;                            val subjectId = subjects.find { it.name == entry.subject }?.id ?: 0&#10;                            coroutineScope.launch {&#10;                                if (dismissState.value == CustomDismissValue.DismissedToEnd) {&#10;                                    attendanceViewModel.markAttendance(&#10;                                        subjectId = subjectId,&#10;                                        selectedSlots = selectedSlots,&#10;                                        date = todayDate.toString(),&#10;                                        status = AttendanceStatus.PRESENT&#10;                                    )&#10;                                    errorMessage = &quot;Marked Present for ${entry.subject}&quot;&#10;                                } else if (dismissState.value == CustomDismissValue.DismissedToStart) {&#10;                                    attendanceViewModel.markAttendance(&#10;                                        subjectId = subjectId,&#10;                                        selectedSlots = selectedSlots,&#10;                                        date = todayDate.toString(),&#10;                                        status = AttendanceStatus.ABSENT&#10;                                    )&#10;                                    errorMessage = &quot;Marked Absent for ${entry.subject}&quot;&#10;                                }&#10;                                dismissState.value = CustomDismissValue.Default&#10;                            }&#10;                        }&#10;                        CustomSwipeToDismiss(&#10;                            state = dismissState,&#10;                            background = { direction -&gt;&#10;                                val color = when (direction) {&#10;                                    CustomDismissDirection.StartToEnd -&gt; MaterialTheme.colorScheme.primary&#10;                                    CustomDismissDirection.EndToStart -&gt; MaterialTheme.colorScheme.error&#10;                                }&#10;                                Box(&#10;                                    Modifier&#10;                                        .fillMaxSize()&#10;                                        .background(color)&#10;                                )&#10;                            },&#10;                            content = {&#10;                                Card(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(8.dp),&#10;                                    elevation = CardDefaults.cardElevation(2.dp)&#10;                                ) {&#10;                                    Column(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .padding(16.dp)&#10;                                    ) {&#10;                                        Text(entry.subject, style = MaterialTheme.typography.titleMedium)&#10;                                        Text(&quot;${entry.startTime} - ${entry.endTime}&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                        // --- Attendance Progress Bar ---&#10;                                        val subjectObj = subjects.find { it.name == entry.subject }&#10;                                        val attended = subjectObj?.attendedClasses ?: 0&#10;                                        val total = subjectObj?.totalClasses ?: 0&#10;                                        val threshold = subjectObj?.threshold ?: 75&#10;                                        val attendancePercent = if (total &gt; 0) attended * 100 / total else 0&#10;                                        val thresholdPercent = threshold &#10;                                        Spacer(modifier = Modifier.height(8.dp))&#10;                                        Box(modifier = Modifier.fillMaxWidth().height(20.dp)) {&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxSize()&#10;                                                    .background(MaterialTheme.colorScheme.secondary.copy(alpha = 0.5f))&#10;                                            )&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxHeight()&#10;                                                    .fillMaxWidth(fraction = thresholdPercent / 100f)&#10;                                                    .background(MaterialTheme.colorScheme.error.copy(alpha = 0.75f))&#10;                                            )&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxHeight()&#10;                                                    .fillMaxWidth(fraction = attendancePercent / 100f)&#10;                                                    .background(MaterialTheme.colorScheme.primary)&#10;                                            )&#10;                                        }&#10;                                        Spacer(modifier = Modifier.height(2.dp))&#10;                                        Row(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.SpaceBetween&#10;                                        ) {&#10;                                            Text(&quot;Attendance: $attendancePercent%&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                            Text(&quot;Threshold: $thresholdPercent%&quot;, style = MaterialTheme.typography.bodyMedium)&#10;                                        }&#10;                                        // --- Edit/Delete Controls ---&#10;                                        Row(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.End&#10;                                        ) {&#10;                                            IconButton(onClick = {&#10;                                                editingEntry = entry&#10;                                                subject = entry.subject&#10;                                                startTime = entry.startTime&#10;                                                endTime = entry.endTime&#10;                                                showDialog = true&#10;                                            }) {&#10;                                                Icon(Icons.Filled.Edit, contentDescription = &quot;Edit&quot;)&#10;                                            }&#10;                                            IconButton(onClick = {&#10;                                                coroutineScope.launch {&#10;                                                    timetableViewModel.deleteEntry(entry)&#10;                                                    errorMessage = &quot;Entry deleted&quot;&#10;                                                }&#10;                                            }) {&#10;                                                Icon(Icons.Filled.Delete, contentDescription = &quot;Delete&quot;)&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (showDialog) {&#10;                var subjectDropdownExpanded by remember { mutableStateOf(false) }&#10;                val subjectOptions = subjects.map { it.name }&#10;                var selectedSubject by remember { mutableStateOf(subjectOptions.firstOrNull() ?: &quot;&quot;) }&#10;                val selectedSlotIds = remember { mutableStateListOf&lt;Int&gt;() }&#10;                var slotSelectionError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;            &#10;                AlertDialog(&#10;                    onDismissRequest = { showDialog = false },&#10;                    confirmButton = {&#10;                        Button(onClick = {&#10;                            if (selectedSubject.isBlank() || selectedSlotIds.isEmpty() || slotSelectionError != null) {&#10;                                errorMessage = slotSelectionError ?: &quot;Please select subject and valid slots.&quot;&#10;                                return@Button&#10;                            }&#10;                            coroutineScope.launch {&#10;                                val selectedSlots = slotEntities.filter { selectedSlotIds.contains(it.id) }&#10;                                    .sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)) }&#10;                                val startStr = selectedSlots.first().startTime&#10;                                val endStr = selectedSlots.last().endTime&#10;                                if (editingEntry == null) {&#10;                                    timetableViewModel.addEntry(&#10;                                        TimetableEntry(&#10;                                            dayOfWeek = today ,&#10;                                            subject = selectedSubject,&#10;                                            startTime = startStr,&#10;                                            endTime = endStr,&#10;                                            slotIds = selectedSlotIds.toList()&#10;                                        )&#10;                                    )&#10;                                    errorMessage = &quot;Entry added&quot;&#10;                                } else {&#10;                                    timetableViewModel.deleteEntry(editingEntry!!)&#10;                                    timetableViewModel.addEntry(&#10;                                        TimetableEntry(&#10;                                            id = editingEntry!!.id,&#10;                                            dayOfWeek = today ,&#10;                                            subject = selectedSubject,&#10;                                            startTime = startStr,&#10;                                            endTime = endStr,&#10;                                            slotIds = selectedSlotIds.toList()&#10;                                        )&#10;                                    )&#10;                                    errorMessage = &quot;Entry updated&quot;&#10;                                }&#10;                                showDialog = false&#10;                            }&#10;                        }) {&#10;                            Text(&quot;Save&quot;)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        OutlinedButton(onClick = { showDialog = false }) {&#10;                            Text(&quot;Cancel&quot;)&#10;                        }&#10;                    },&#10;                    title = { Text(if (editingEntry == null) &quot;Add Timetable Entry&quot; else &quot;Edit Timetable Entry&quot;) },&#10;                    text = {&#10;                        Column {&#10;                            Text(&quot;Select Subject:&quot;)&#10;                            ExposedDropdownMenuBox(&#10;                                expanded = subjectDropdownExpanded,&#10;                                onExpandedChange = { subjectDropdownExpanded = it }&#10;                            ) {&#10;                                OutlinedTextField(&#10;                                    value = selectedSubject,&#10;                                    onValueChange = {},&#10;                                    readOnly = true,&#10;                                    label = { Text(&quot;Subject&quot;) },&#10;                                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = subjectDropdownExpanded) },&#10;                                    modifier = Modifier.menuAnchor()&#10;                                )&#10;                                ExposedDropdownMenu(&#10;                                    expanded = subjectDropdownExpanded,&#10;                                    onDismissRequest = { subjectDropdownExpanded = false }&#10;                                ) {&#10;                                    subjectOptions.forEach { subj -&gt;&#10;                                        DropdownMenuItem(&#10;                                            text = { Text(subj) },&#10;                                            onClick = {&#10;                                                selectedSubject = subj&#10;                                                subjectDropdownExpanded = false&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&quot;Select Time Slots (≤20 min gap):&quot;)&#10;                            Box(modifier = Modifier.height(220.dp)) {&#10;                                LazyColumn {&#10;                                    items(slotEntities.sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)) }) { slot -&gt;&#10;                                        val checked = selectedSlotIds.contains(slot.id)&#10;                                        Button(&#10;                                            onClick = {&#10;                                                if (!checked) {&#10;                                                    val allSelected = selectedSlotIds + slot.id&#10;                                                    val sortedSlots = slotEntities.filter { allSelected.contains(it.id) }&#10;                                                        .sortedBy { LocalTime.parse(it.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;)) }&#10;                                                    val valid = sortedSlots.zipWithNext().all { (a, b) -&gt;&#10;                                                        val aEnd = LocalTime.parse(a.endTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;))&#10;                                                        val bStart = LocalTime.parse(b.startTime, DateTimeFormatter.ofPattern(&quot;hh:mm a&quot;))&#10;                                                        java.time.Duration.between(aEnd, bStart).toMinutes() &lt;= 20&#10;                                                    }&#10;                                                    if (valid) {&#10;                                                        selectedSlotIds.add(slot.id)&#10;                                                        slotSelectionError = null&#10;                                                    } else {&#10;                                                        slotSelectionError = &quot;Selected slots must be consecutive with ≤20 min gap.&quot;&#10;                                                    }&#10;                                                } else {&#10;                                                    selectedSlotIds.remove(slot.id)&#10;                                                    slotSelectionError = null&#10;                                                }&#10;                                            },&#10;                                            colors = ButtonDefaults.buttonColors(&#10;                                                containerColor = if (checked) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.surface,&#10;                                                contentColor = if (checked) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface&#10;                                            ),&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .padding(vertical = 4.dp)&#10;                                        ) {&#10;                                            Text(&quot;${slot.label}: ${slot.startTime} - ${slot.endTime}&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                            if (slotSelectionError != null) {&#10;                                Text(slotSelectionError!!, color = MaterialTheme.colorScheme.error)&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>